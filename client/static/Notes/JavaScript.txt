=========================================================================================================
											JavaScript
=========================================================================================================

Introduction
	
	JavaScript is a popular programming language used in web development. It adds interactivity and dynamic content to websites. As a beginner, learning JavaScript can empower you to create interactive buttons, forms, and animations. It's essential to grasp fundamental concepts like variables, functions, and conditions to start building exciting web projects.
	
	Some topics may not be fully explored in here so Consider Checking The MDN reference for Extra Details: https://developer.mozilla.org/en-US/

Chapters:

	1. Basics
		|- Variables
		|- Scope
		|- Data Types
		|- console.log
		|- Operators and Expressions
		|- Comments
		|- Conditional Expressions
		|- Index
		|- Loops
		|- Functions
		|- Arrays

	2. JavaScript in Browser (Client Side)
		|- Window
		|- Document Object Model (DOM)
		|- Browser Object Model (BOM)
		|- Auto-Correction by The Browser
		|- Events

	3. Key Concepts
		|- Synchronous and Asynchronous
		|- Advance Functions
		|- Pyramid of Doom
		|- Keywords
		|- Promises
		|- Async/Await
		|- Try..Catch
		|- Errors
		|- Network
	
	4. Object Oriented Programming
		|- Prototypes
		|- Objects
		|- Classes

	5. High-End/Advance JavaScript
		|- IIFE
		|- Destructuring assignment
		|- Scopes
		|- Hoisting
		|- Closures
		|- Regular Expressions
		|- How JavaScript Works

	6. Node.js
		|- Terminal Commands for JS
		|- Package Manager
		|- Modules

Section: Basics

1. Variables

	In JavaScript, variables are like containers that hold data. They allow us to store and manipulate information, such as numbers, text, or objects. To create a variable, we use the 'let' or 'const' keyword, followed by a name. We can change the value of a variable anytime, making it flexible for coding tasks. For example:
		
		let age = 25; // A variable named 'age' with the value 25
		const name = "John"; // A constant variable named 'name' with the value "John"

	Here's some keywords to declare a variable

	(i) var :"If you using this keyword to declare a variable then the variable can easily be reclared and change it's data" (note: this keyword to declare a variable is used in very old code and nowadays no-one really uses it try using other keywords to declare a variable)

	(ii) let :"Using this keyword the variables can't be re-declared but something can be added after words using this code:-`variable = value` " (recommended)
	
	(iii) const :"If you declare a variable using this keyword then there's no way possible way to change it's data once declared, and yes you can transfer it's data to a variable which can maybe re-declared but the the variable declared using this keyword will not effected at all"
	
	(note: You can't use any numbers at beginning of the name the variable without a string and you also can't even use any preserved keywords of JavaScript)

2. Scope
	
	(i) When code is inside a bracket It's variables only exists until the variable closes

	(ii) something like this for example:-

	{
		let variable = "Data"
		console.log(variable) // Data
	}
	console.log(variable) // Error: varible is not defined
	
3. Data Types 

	(i) Primitive Data Types: There are Total 7 Primitive Data Types
		Here's List of Primitive Data Types

		(a) `Null`: Literal Nothing
		(b) `Number`: Number
		(c) `BigInt`: Big Integer
		(d) `Booleon`: Byte Data (`true` and `false`)
		(e) `String`: Contains Text of Your Choice
	
			(I) String is used to store chunks of text
			(II) String can be used by Sets of:- 
				
				(A) Double Quotes("text") 
				(B) Single Quotes('text') 
				(C) Template literal" ` "

					I. Syntax: Template literals use backticks to enclose the string content. For example:-

						const name = "Alice";
						const greeting = `Hello, ${name}!`;

					II. Embedded Expressions: One of the primary advantages of template literals is the ability to embed expressions within the string using ${}. These expressions are evaluated, and their results are inserted into the string.

						const x = 10;
						const y = 20;
						const sum = `The sum of ${x} and ${y} is ${x + y}.`;

					III. Multiline Strings: Template literals make it easy to create multiline strings without needing to include explicit line breaks or concatenation. You can simply press Enter within the backticks to create new lines:

						const multiline = `
						This is a
						multiline string
						created with
						template literals.
						`;

					IV. Escaping Backticks: To include an actual backtick character within a template literal, you can escape it with a backslash (\). For example:-

						const textWithBacktick = `This is a backtick: \` inside a template literal.`;

					V. Expression Evaluation: Expressions within ${} are evaluated, so you can include any valid JavaScript expression. This allows for complex calculations, function calls, or even conditional logic within template literals.

						const value = 5;
						const squared = `The square of ${value} is ${value ** 2}.`;

					VI. Tagged Templates (Advanced): Template literals can also be used with a tag function, which allows you to process the template literal's contents using a custom function. This advanced feature is useful for tasks like internationalization, escaping, or custom formatting of strings.

						function customTag(strings, ...values) {
						    // Custom processing of strings and values
						}
						const result = customTag`This is a ${value}.`;
						
			(III) `String.length` Gives The length of the String			
			(VI) A backslash(\) right before a letter inside The String Makes the System Consider The Letter as a Text. for Example:-

				let a = 'What\'s this?'
				console.log(a) // Prints: What's this

				(Note: backslash(\) itself will not be include in the string, it requires another blackslah to display one.)
				
		(VI) `Symbol`: A Unique identifier
		(VII) `Undefined`: represents that it's not defined
		
	(ii) Non-primitive Data Types

		(Note: It's Recommended to Skip this Section for now since it's very Advance JavaScript)

		(a) `Object`: The most basic non-primitive type. It represents a collection of key-value pairs. Almost all other non-primitive types in JavaScript inherit from Object.

			(This Section is Explained Later in The Notes)

			let person = { name: "James", age: 30 };

    	(b) `Array`: An ordered collection of data (elements), where each element can be of any type. Arrays in JavaScript are actually a special kind of object.

			(This Section is also Explained Later in The Notes)

			let numbers = [1, 2, 3, 4, 5];

    	(c) `Function`: Functions in JavaScript are first-class objects, meaning they can have properties and methods just like any other object.

			(This Section is also Explained Later in The Notes)
			
			function greet(name) {
				return `Hello, ${name}!`;
			}

    	(d) `Date`: Represents a single moment in time in a platform-independent format. Date objects contain methods for date and time operations.

			(This Section is also Explained Later in The Notes)

			let now = new Date();

    	(e) `RegExp (Regular Expression)`: Used for matching text with a pattern. RegExp objects have methods and properties for pattern matching and text manipulation.
			
			(This Section is also Explained Later in The Notes)

			let pattern = /hello/;

    	(f) `Map` 

			(I) The Map object in JavaScript is a collection of key-value pairs. It is part of the ECMAScript 6 (ES6) specification and offers several advantages over traditional objects when used as a hash map. Here are some of the key characteristics and functionalities of a Map:
			Key Characteristics of Map

			    (A) ey Types: Unlike objects, which only use strings and symbols as keys, Map allows keys of any type, including functions, objects, and any primitive.

			    (B) Order of Elements: Map objects maintain the insertion order of their elements, meaning you can rely on the order in which key-value pairs are added.

			    (C) Size Property: You can easily get the number of key/value pairs in the Map with its size property.

			    (D) Performance: For large sets of data, particularly when adding and removing elements, Map often performs better than objects.

			(II) Basic Operations

			    (A) Creating a Map:

					let map = new Map();

				(B) Setting Key-Value Pairs:

					map.set('key1', 'value1');
					map.set('key2', 'value2');

				(C) Getting a Value:

					let value = map.get('key1'); // 'value1'

				(D) Checking for a Key:

					map.has('key1'); // true

				(E) Removing a Key-Value Pair:

					map.delete('key1'); // Removes the pair with key 'key1'

				(F) Clearing the Map:

					map.clear(); // Removes all key-value pairs

				(G) Getting the Size:
					let size = map.size; // Returns the number of key/value pairs

			(III) Iteration and Looping

			    (A) forEach Method:

					map.forEach((value, key)=>{
					  	console.log(key + ' = ' + value);
					});

				(B) Iterating Over `Keys`, `Values`, and `Entries`:

			    	I. Keys:

						for (let key of map.keys()) {
						  	console.log(key);
						}

					II. Values:

						for (let value of map.values()) {
						  	console.log(value);
						}

					III. Entries (key-value pairs):
		
					    for (let [key, value] of map.entries()) {
					      console.log(key + ' = ' + value);
					    }

				(C) for...of loop

			    	for (let [key, value] of map) {
			    	  console.log(key + ' = ' + value);
			    	}

    	(g) `Set` 

			(I) A Set in JavaScript is a collection of unique values. It was introduced in ECMAScript 6 (ES6) and provides an efficient way to handle collections of values where uniqueness is important. Here are some key characteristics and functionalities of a Set:
			Key Characteristics of Set

			    (A) Unique Values: A Set can only contain unique values. If you try to add a duplicate value, it will be ignored.

			    (B) No Key-Value Pairs: Unlike Map, a Set doesn't have key-value pairs; it only stores individual values.

			    (C) Order of Elements: Similar to Map, Set maintains the insertion order of its elements.

			    (D) Size Property: You can easily get the number of unique values in the Set with its size property.

			    (E) Performance: Set provides efficient methods for adding, deleting, and checking the existence of elements.

			(II) Basic Operations

				(A) Creating a Set:

					let set = new Set();

				(B) Adding Values:

					set.add(1);
					set.add(2);
					set.add(3);

				(C) Checking for Existence:

					set.has(2); // true

				(D) Deleting a Value:


					set.delete(2); // Removes the value 2 from the set

				(E) Clearing the Set:


					set.clear(); // Removes all values from the set

				(F) Getting the Size:


				    let size = set.size; // Returns the number of unique values

			(III) Iteration and Looping

			    (A) forEach Method:

					set.forEach(function(value) {
					  	console.log(value);
					});

				(B) Iterating Over Values with for...of:

					for (let value of set) {
					  	console.log(value);
					}

    	(h) `WeakMap`: A variant of Map that allows only objects as keys and does not prevent garbage collection if there are no other references to the key.

			let weakMap = new WeakMap();
			let obj = {};
			weakMap.set(obj, { key: "value" });

    	(i) `WeakSet`: Similar to Set but with weaker references to its values. It only allows objects and doesn't prevent their garbage collection.

			let weakSet = new WeakSet();
			let obj = {};
			weakSet.add(obj);

    	(j) `Promise`: Represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.

			(This Section is also Explained Later in The Notes)

			let promise = new Promise((resolve, reject) => {
			  	setTimeout(() => resolve("done"), 1000);
			});

    	(k) `TypedArray`

			(I) Typed Arrays in JavaScript provide a way to work with binary data. They were introduced to cater to the needs of applications like WebGL, where it is necessary to control and manipulate data at the binary level, and for performance-critical applications like audio processing, 3D graphics, or real-time video processing.

			(II) Key Characteristics of Typed Arrays

    			(A) Binary Data Handling: Typed arrays allow you to work directly with fixed-size binary data buffers.

    			(B) Fixed-Size Elements: Unlike regular arrays, each element in a typed array is of a specific size and type. For example, an Int8Array represents an array of 8-bit signed integers.

    			(C) Efficient: They provide a more efficient way to handle large amounts of binary data. The operations on typed arrays are typically much faster than those on regular JavaScript arrays.

    			(D) ArrayBuffer: Typed arrays work on an ArrayBuffer. This buffer is a raw binary data buffer which you can access through a typed array view.

			(III) Basic Operations

    			(A) Creating a Typed Array:

					let int16 = new Int16Array(2);
					int16[0] = 42;

				(B) Creating from an ArrayBuffer:
				
					let buffer = new ArrayBuffer(16); // create a buffer of 16 bytes
					let view = new Int32Array(buffer); // view the buffer as 32-bit integers

				(C) Reading and Writing: You can access elements using standard array syntax.

					let value = int16[0]; // read
					int16[1] = 23; // write

				(D) Length and ByteLength:

					int16.length; // gives the number of elements
					int16.byteLength; // gives the size in bytes

			(IV) Use Cases:

    			(a) Handling Binary Data: Typed arrays are used when dealing with files, such as images or videos, and for network operations.
    			(b) WebGL: They are used extensively in WebGL for dealing with image textures, vertex buffers, etc.
    			(c) Web Audio API: For processing audio data.
    			(d) High-Performance Computing: Any application that requires manipulation of complex datasets, like scientific calculations or real-time graphics, can benefit from typed arrays.

			(V) `arrayBuffer()`: Used to Receive File from Server-to-Server

				(async () => {
				    const Request = await fetch(URL);
				    const File = await Request.arrayBuffer()

					fs.writeFileSync('./myfile.jpg', File)
				})()

    	(l) `Buffer (Node.js specific)`
			
			(I) In Node.js, a Buffer is a global object used to work directly with binary data. It represents a fixed-size chunk of memory allocated outside the V8 JavaScript engine. Buffers are particularly useful in scenarios where you need to handle raw binary data, like when working with files, streams, or implementing network protocols.
			
			(I) Key Characteristics of Buffers:

    			(A) Binary Data: Buffers store raw binary data. Each slot in a Buffer can store one byte of data, making them suitable for handling binary data streams.

    			(B) Fixed Size: A Buffer is created with a fixed size (in bytes) when instantiated and cannot be resized.

    			(C) Array-like: Buffers are similar to arrays of integers, where each element is a byte (value between 0 and 255).

    			(D) Encoding/Decoding: Buffers can be used to convert data to/from various encodings (like UTF-8, Base64, etc.).
			
			Example:-
				
				let buffer = Buffer.from('Hello, world!', 'utf-8') // <Buffer 48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21>
			
			(II) Creating Buffers:

				(A) Buffers can be created in several ways:

				(B) Allocating a Buffer:

					const buffer = Buffer.alloc(10); // Allocates a buffer of 10 bytes

				(B) From Existing Data:

					const buffer = Buffer.from([1, 2, 3, 4, 5]); // Creates a buffer containing [1, 2, 3, 4, 5]
					const bufferFromString = Buffer.from("Hello", "utf-8"); // Creates a buffer from a string

				(C) Unsafe Buffer Allocation:

					const buffer = Buffer.allocUnsafe(10); // Faster, but may contain old data

				allocUnsafe is faster than alloc as it does not initialize the buffer memory. However, the allocated segment of memory may contain old data and needs to be overwritten to avoid security issues.
				
			(III) Working with Buffers:

    			(A) Reading and Writing: Buffers allow you to read and write data at specific offsets.

					const buf = Buffer.from("Hello World");
					console.log(buf) // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64>
					console.log(buf.toString('utf8')); // "Hello Wolrd"

					buf.write("Hi", 0); // Overwrites the buffer with "Hi" at the beginning
					console.log(buf) // <Buffer 48 69 6c 6c 6f 20 57 6f 72 6c 64>
					console.log(buf.toString('utf8')) // Hillo World

				(B) Slicing: You can create a new buffer that points to the same memory as the original buffer, but starting at a different offset and with a different length.

					const buf = Buffer.from("Hello World");
					const slice = buf.slice(0, 5); // Slices the buffer to contain "Hello"

				(C) Buffer Length: The length of a buffer (in bytes) can be accessed using the length property.

					const buffer = Buffer.from("Hello World");
					console.log(buffer.length); // Outputs the length of the buffer
				
				(D) Use Cases for Buffers:

    				I. File System Operations: Reading and writing binary files (like images, videos, etc.).
    				II. Networking: Handling TCP streams, where data is often received as a stream of binary packets.
    				III. Stream Processing: Manipulating data in streams, like compressing or encrypting data.
    				IV. Interacting with the Operating System: For example, when working with system calls that require binary data.

    	(m) `Blob (commonly used in web APIs)`:

			(I) A Blob (Binary Large Object) represents immutable raw binary data in web development, commonly used in JavaScript within web browsers. Blobs are typically used to handle data like files, images, or other binary data that might be transferred over the network or stored on the client side.
			(II) Key Characteristics of Blobs:

			    (A) Binary Data: Blobs are used to handle raw binary data. This makes them suitable for a wide range of applications, including file operations, media manipulation, and network transfers.

			    (B) Immutable: Once a Blob object is created, the data it contains cannot be modified. However, you can create a new Blob from an existing one with modifications.

			    (C) Efficient Memory Usage: Blobs are designed to efficiently handle large chunks of data. They don't necessarily load all data into memory at once, which makes them suitable for handling large files.

			    (D) Readable As Various Data Types: Although a Blob contains binary data, it can be read as text, ArrayBuffer, or even converted into a data URL.

			(III) Creating Blobs: Blobs can be created using the Blob constructor:

				(A) Syntax:

					new Blob([<data>], { type: <mimeType> });

				    I. data: This is the raw data you want to put into the Blob. It can be a string, a BufferSource, or even another Blob.
				    type: This optional argument is a string representing the MIME type of the data.

				Example:-

					const text = "Hello, world!";
					const blob = new Blob([text], { type: 'text/plain' });

			(IV) Common Uses and Operations:

			    (A) File Operations: In web applications, Blobs are often used to represent file data. This can be used for operations like file downloads, uploads, or previews.

			    (B) Converting Between Formats: You can convert a Blob to and from various formats. For example, using FileReader to read a Blob as text, or converting an image into a Blob for upload.

			    (C) Creating Object URLs: `Using URL.createObjectURL()`, you can create a URL that represents the Blob data. This is useful for displaying Blob data as an image source or downloading it as a file.

			    	const url = URL.createObjectURL(blob);

			    (D) Reading Blob Content: To read content from a Blob, you can use the FileReader API or the newer `Blob.text()`, `Blob.arrayBuffer()`, and `Blob.stream()` methods.

			(V) Differences from ArrayBuffer:

			    ArrayBuffer is a low-level interface representing a buffer of binary data; it can be manipulated with a TypedArray or DataView.
			    Blob is higher-level, used more with file-like objects in web APIs, and tends to be used in APIs that handle data in a file-like format.

    	(n) `File (commonly used in web APIs)`

			(I) the File data type is a specific kind of Blob that represents data from the file system. It's used in JavaScript within web browsers and is part of the File API, a standard for handling file inputs in web applications. The File object provides information about files and allows you to read from them.

			(II) Key Characteristics of the File Object:

    			(A) Inherits from Blob: File inherits all the properties and methods from the Blob class, such as size, type, and methods like slice(). This means it can be used in any context where a Blob is used, like in fetch or XMLHttpRequest.

    			(B) File Metadata: In addition to the binary content, the File object includes metadata such as the file's name and the last modified date.

    			(C) Immutability: Similar to a Blob, a File object is immutable. You can't change its content or metadata after it's created.

			(III) Creating a File Object: A File object is typically obtained from a file input element (`<input type="file">`), from `drag-and-drop` operations, or from the Clipboard API. You can also create a File object programmatically:

				const file = new File([<blobPart>], <fileName>, { type: <Type>, lastModified: <date> });

				blobPart: The raw data of the file, which can be a BufferSource, Blob, String, etc.
    			fileName: The name of the file.
    			options: An optional object where you can set the MIME type (type) and the last modification date (lastModified).

			(IV) Common Operations and Uses:

    			(A) Reading File Content: To read content from a File, you can use the FileReader API or the methods available on the Blob object, like text(), arrayBuffer(), and stream().

    			(B) Uploading Files: File objects are commonly used to upload files to a server. You can include them in FormData and use them with fetch or XMLHttpRequest for asynchronous file uploads.

    			(C) Manipulating File Data: While you can't modify a File object directly, you can read its data, process it, and create new Blob or File objects from the results.
			
			(V) Example: Here’s a basic example of how a File object might be used in a web application:

				<input type="file" id="fileInput">
				<script>
					document.getElementById('fileInput').addEventListener('change', function(event) {
					    const file = event.target.files[0]; // Get the selected file
					    const reader = new FileReader();

					    reader.onload = function(e) {
					        const fileContent = e.target.result;
					        console.log("File content:", fileContent);
					    };

					    reader.readAsText(file); // Read the file content as text
					});
				</script>

				In this example, when a user selects a file, the File object is read as text, and its content is logged to the console.

    	(o) `Error`: Represents runtime errors. Various types of error objects (like SyntaxError, TypeError, ReferenceError) inherit from this.

			(This Section is also Explained Later in The Notes)

			let error = new Error("Something went wrong");

    	(p) `Proxy`

			(I) A Proxy is an object that wraps another object (known as the target) and intercepts operations performed on it. Proxies provide a way to customize the behavior of fundamental operations on objects, allowing you to implement custom behavior such as validation, logging, or access control.

			(II) Key Characteristics of Proxies:

    			(A) Interception of Operations: Proxies allow you to intercept and override fundamental operations like property access, assignment, function invocation, etc., on the target object.

    			(B) Customizable Behavior: You can define custom behavior for each intercepted operation, giving you fine-grained control over how the target object is accessed or modified.

    			(C) Transparent Operation: From the perspective of the code using a proxy, it appears as if it is interacting directly with the target object. The proxy sits between the code and the target, transparently modifying the behavior.

    			(D) Non-intrusive: Proxies don't modify the target object directly. Instead, they provide a wrapper around the target, leaving the target unchanged.
			
			(III) Creating a Proxy:

				(A) You can create a proxy using the Proxy constructor, which takes two parameters: the target object and a handler object with methods that define the custom behavior for various operations.

					const target = { name: 'John', age: 30 };
					const handler = {
					  	get: (target, property)=>{
							
					    	console.log(`Getting property "${property}"`); // Logs Whenever Someone Tries to Access The Property

					    	return target[property]; // Returns The Property
					  	},
					  	set: (target, property, value)=>{
					    	
							console.log(`Setting property "${property}" to ${value}`); // Logs Whenever Someone Tries to Set The Property

					    	target[property] = value; // Sets The Property
					  	}
					};

					const proxy = new Proxy(target, handler);

					In this example, the handler object contains methods like get and set that will be called when a property is accessed or modified on the proxy.

			(IV) Common Use Cases for Proxies:

    			(A) Validation: You can use proxies to enforce validation rules when setting or getting properties.

					const safeObject = new Proxy({}, {
					  	set: function(target, property, value) {
					    	if (typeof value === 'number') {
					      		target[property] = value;
					    	} else {
					      		console.error(`Invalid value for property "${property}"`);
					    	}
					  	}
					});

					safeObject.age = 25; // Valid
					safeObject.age = 'invalid'; // Invalid

				(B) Logging: Proxies are often used to log interactions with objects, providing insights into how an object is being used.

					const loggingProxy = new Proxy(target, {
					  	get: function(target, property) {
					    	console.log(`Getting property "${property}"`);
					    	return target[property];
					  	}
					});

					console.log(loggingProxy.name); // Logs "Getting property "name""

				(C) Access Control: Proxies can be used to restrict or control access to certain properties of an object.

					const privateData = { secret: 'shhh!' };
	
					const accessControlledObject = new Proxy(privateData, {
					  	get: function(target, property) {
					    	if (property === 'secret') {
					      		console.error('Access to secret denied');
					      		return undefined;
					    	} else {
					      		return target[property];
					    	}
					  	}
					});

					console.log(accessControlledObject.publicInfo); // Allowed
					console.log(accessControlledObject.secret); // Access denied, logs an error

			(V) Limitations and Considerations:

    			(A) Performance Overhead: Proxies introduce some performance overhead compared to direct property access. While this is generally negligible for most use cases, it's important to be mindful of performance in critical sections of your code.

    			(B) Non-trapable Operations: Some operations, like hasOwnProperty, cannot be trapped by proxies.

    			(C) Extensibility: Proxies work well with objects, but not all operations can be proxied for non-extensible objects or certain built-in objects.

    	(q) `Intl`: Internationalization constructors for string comparison, number formatting, and date and time formatting. Examples include Intl.DateTimeFormat, Intl.NumberFormat.

			let numberFormatter = new Intl.NumberFormat('en-US');
			let formattedNumber = numberFormatter.format(1234567.89);

    	(r) `Generator`: Functions that can return multiple values, either sequentially or asynchronously, by pausing execution and resuming later.

			function* idGenerator() {
			  let id = 0;
			  while (true) {
			    yield id++;
			  }
			}
			let generator = idGenerator();
		
4. `console.log()`
	
	(i) to print something in the output it can be used by typing this "console.log"
	(ii) add closed round brackets in front of it (without space)
	(iii) put the name of the variable in the round brackets, It'll look something like this "console.log(variable)"
	(iv) If you want to add multiple variable then put a space and add a plus("+") sign and then a space then type the variable name you can do this many times as you want and also you can also put strings number too. 
	(v) You can also use any arithmetic operators or Assignment Operator (They are list below in Section 5),  but make sure that the data inside all of the variable is a number not anything else only for the ones you're using
	(vi) If you want to know what is the type of the variable then do "console.log(typeof variable)", It will print the type of the variable in the Output
	(vii) to look up for something in JavaScript type this "console.log(variable['key'])" it can also be done by "console.log(variable.key)" if the key is not a string, It will Show The Value of The Key in The Object
	
5. Operators and Expressions
	
	(i) To do the Basic Mathematics Operands and Operators are used in it
	(ii) Operands are The Numbers that are going to be used
	(iii) Operators are the keys like division, multiplication, subtraction, or addition
	
	(iv) Arithmetic Operators
		
		(a) `+` Addition: The `+` operator is used for addition.
			
			(I) It adds numeric values or concatenates strings. When used with strings, it concatenates the second string to the end of the first string. For example, 2 + 3 returns 5, and "Hello" + " " + "World" returns "Hello World".
		(b) `-` Subtraction: The `-` operator subtracts the second operand from the first.
			
			(I) It can be used with numeric values. For example, 5 - 3 returns 2.
		(c) `*` Multiplication: The `*` operator multiplies the operands.
			
			(I) It is used to multiply numeric values. For example, 2 * 3 returns 6.
		(d) `/` Division: The `/` operator divides the first operand by the second.
			
			(I) It is used to perform division operations on numeric values. For example, 6 / 2 returns 3.
		(e) `%` Modulus: The `%` operator returns the division remainder.
			
			(I) It is used to find the remainder after division. For example, 5 % 2 returns 1.
		(f) `++` Increment: The `++` operator increments the numeric value by one.
			
			(I) It can be used as a prefix or postfix operator. For example, let a = 5; a++; would result in a being 6.
		(g) `--` Decrement: The -- operator decreases the numeric value by one.
			
			(I) It can be used as a prefix or postfix operator. For example, let b = 5; b--; would result in b being 4.
	
	(v) Assignment operators

		Arithmetic Assignment:

		(a) `=` Assignment Operator: The `=` operator assigns a value to a variable.
			
			(I) It is used to assign the value on the right to the variable on the left. For example, x = 5 assigns the value 5 to the variable x.

		(b) `+=` Addition Assignment: The `+=` operator adds the value on the right to the variable and assigns the result to the variable.
			
			(I) For example, x += 3 is the same as x = x + 3.

		(c) `-=` Subtraction Assignment: The `-=` operator subtracts the value on the right from the variable and assigns the result to the variable.
			
			(I) For example, x -= 3 is the same as x = x - 3.

		(d) `*=` Multiplication Assignment: The `*=` operator multiplies the variable by the value on the right and assigns the result to the variable.
			
			(I) For example, x *= 3 is the same as x = x * 3.

		(e) `/=` Division Assignment: The `/=` operator divides the variable by the value on the right and assigns the result to the variable.
			
			(I) For example, x /= 3 is the same as x = x / 3.

		(f) `%=` Modulus Assignment: The `%=` operator performs modulus division on the variable and the value on the right and assigns the result to the variable.
			
			(I) For example, x %= 3 is the same as x = x % 3.

		Bitwise Assignment:
		
		(g) `Bitwise AND Assignment (`&=`)`: Performs a bitwise AND operation between the variable and the value on the right side of the operator, and then assigns the result to the variable.

		   	var x = 5;
		   	x &= 3; // Equivalent to x = x & 3;
		   	console.log(x); // Output: 1 (5 & 3 = 1)

		(h) `Bitwise OR Assignment (`|=`)`: Performs a bitwise OR operation between the variable and the value on the right side of the operator, and then assigns the result to the variable.

		   	var x = 5;
		   	x |= 3; // Equivalent to x = x | 3;
		   	console.log(x); // Output: 7 (5 | 3 = 7)

		(i) `Bitwise XOR Assignment (`^=`)`: Performs a bitwise XOR operation between the variable and the value on the right side of the operator, and then assigns the result to the variable.

		   	var x = 5;
		   	x ^= 3; // Equivalent to x = x ^ 3;
		   	console.log(x); // Output: 6 (5 ^ 3 = 6)

		(j) `Left Shift Assignment (`<<=`)`: Shifts the bits of the variable to the left by the number of positions specified on the right side of the operator, and then assigns the result to the variable.

		   	var x = 5;
		   	x <<= 1; // Equivalent to x = x << 1;
		   	console.log(x); // Output: 10 (5 << 1 = 10)

		(k) `Right Shift Assignment (`>>=`)`: Shifts the bits of the variable to the right by the number of positions specified on the right side of the operator, and then assigns the result to the variable.

		   	var x = 5;
		   	x >>= 1; // Equivalent to x = x >> 1;
		   	console.log(x); // Output: 2 (5 >> 1 = 2)

		(l) `Unsigned Right Shift Assignment (`>>>=`)`: Shifts the bits of the variable to the right by the number of positions specified on the right side of the operator, and then assigns the result to the variable. Unlike the right shift operator (`>>`), the unsigned right shift operator (`>>>`) fills the vacated bits with zeros.

		   	var x = -5;
		   	x >>>= 1; // Equivalent to x = x >>> 1;
		   	console.log(x); // Output: 2147483645 (-5 >>> 1 = 2147483645)

	(vi) Comparison Operators
		
		List of Comparison Operators:

		(a) `==` Equality Operator: The `==` operator compares the equality of two operands after converting them to the same type.

			(I) It returns true if the operands are equal. For example, 5 == '5' evaluates to true.
		(b) `===` Strict Equality Operator: The `===` operator checks for both value and type equality.
			
			(I) It returns true only if the operands are of the same type and have the same value. For example, 5 === 5 evaluates to true, but 5 === '5' evaluates to false.
		(c) `!=` Inequality Operator: The `!=` operator checks if two operands are not equal.
			
			(I) It returns true if the operands are not equal and false if they are. For example, 5 != 3 evaluates to true.
		(d) `!==` Strict Inequality Operator: The `!==` operator checks for both value and type inequality.
			
			(I) It returns true if the operands are of different types or have different values. For example, 5 !== '5' evaluates to true, but 5 !== 5 evaluates to false.
		(e) `>` Greater Than Operator: The `>` operator checks if the left operand is greater than the right operand.
			
			(I) It returns true if the left operand is greater, and false otherwise. For example, 5 > 3 evaluates to true.
		(f) `<` Less Than Operator: The `<` operator checks if the left operand is less than the right operand.
			
			(I) It returns true if the left operand is less, and false otherwise. For example, 5 < 3 evaluates to false.
		(g) `>=` Greater Than or Equal Operator: The `>=` operator checks if the left operand is greater than or equal to the right operand.
			
			(I) It returns true if the left operand is greater than or equal, and false otherwise. For example, 5 >= 5 evaluates to true.
		(h) `<=` Less Than or Equal Operator: The `<=` operator checks if the left operand is less than or equal to the right operand.
			
			(I) It returns true if the left operand is less than or equal, and false otherwise. For example, 5 <= 3 evaluates to false.
		(i) `?` Ternary Operator: The ternary operator is a conditional operator that evaluates a condition and returns one of two values based on the result of the evaluation.
			
			(I) It has the syntax condition ? value if true : value if false. For example, let result = (x > 0) ? "positive" : "non-positive"; assigns "positive" to the variable result if x is greater than 0, and "non-positive" otherwise. This operator provides a concise way to write simple conditional statements in JavaScript.
		
	(vii) Logical Operators
		
		list of Logical Operators:

		(a) `&&` Logical AND: The logical AND operator returns true if both operands are true; otherwise, it returns false. For example, let result = (x < 5 && y < 10); returns true if both x is less than 5 and y is less than 10.

		(b) `||` Logical OR: The logical OR operator returns true if at least one of the operands is true; it returns false if both operands are false. For instance, let result = (x < 5 || y < 10); returns true if either x is less than 5 or y is less than 10.

		(c) `!` Logical NOT: The logical NOT operator reverses the logical state of its operand. If a condition is true, the NOT operator makes it false, and vice versa. For example, let result = !(x < 5); returns true if x is not less than 5.

	(viii) Bitwise Operators

		(a) Bitwise operators are used to perform operations on the binary representations of numbers at a bitwise level. These operators manipulate individual bits within binary representations of numbers. Bitwise operators work on 32-bit integer representations of numbers, but they implicitly convert operands to 32-bit signed integers before performing the operation. Here are the bitwise operators available in JavaScript:

		(b) `Bitwise AND (&)`: The bitwise AND operator performs a bitwise AND operation between the corresponding bits of two numbers. The result is 1 only if both bits are 1; otherwise, the result is 0.

		   	var result = 5 & 3; // 0101 & 0011 = 0001
		   	console.log(result); // Output: 1
		   
		(c) `Bitwise OR (|)`: The bitwise OR operator performs a bitwise OR operation between the corresponding bits of two numbers. The result is 1 if at least one of the bits is 1.

		   	var result = 5 | 3; // 0101 | 0011 = 0111
		   	console.log(result); // Output: 7
		   
		(d) `Bitwise XOR (^)`: The bitwise XOR operator performs a bitwise exclusive OR operation between the corresponding bits of two numbers. The result is 1 if the bits are different; otherwise, the result is 0.

		   	var result = 5 ^ 3; // 0101 ^ 0011 = 0110
		   	console.log(result); // Output: 6
		   
		(e) `Bitwise NOT (~)`: The bitwise NOT operator inverts each bit of a number. It changes 1 to 0 and 0 to 1.

		   	var result = ~5; // ~0101 = 1010 (2's complement representation)
		   	console.log(result); // Output: -6
		   
		(f) `Left Shift (<<)`: The left shift operator shifts the bits of a number to the left by a specified number of positions. The vacated bits are filled with zeros.

		   	var result = 5 << 1; // 0101 << 1 = 1010
		   	console.log(result); // Output: 10
		   
		(g) `Sign-propagating Right Shift (>>)`: The right shift operator shifts the bits of a number to the right by a specified number of positions. It preserves the sign of the number, shifting in copies of the leftmost bit (the sign bit).

		   	var result = 5 >> 1; // 0101 >> 1 = 0010
		   	console.log(result); // Output: 2
		   
		(h) `Zero-fill Right Shift (>>>)`: The zero-fill right shift operator shifts the bits of a number to the right by a specified number of positions. It always shifts in zeros from the left.

		   	var result = -5 >>> 1; // 11111111111111111111111111111011 >>> 1 = 01111111111111111111111111111101
		   	console.log(result); // Output: 2147483645
		   
		(i) Bitwise operators are mainly used in situations that require low-level bit manipulation, such as optimizing algorithms, dealing with flags, or working with hardware data. However, they should be used with caution because they can make code less readable and harder to maintain.

	(ix) Unary Operators

		(A) Unary Plus (+): The unary plus operator attempts to convert its operand into a number. If the operand is not already a number, JavaScript tries to convert it using the Number() function.

    		var x = "5";
    		var y = +x; // y will be 5 (a number)

		(B) Unary Negation (-): The unary negation operator negates its operand. If the operand is not already a number, JavaScript tries to convert it into a number and then negates it.

    		var x = "5";
    		var y = -x; // y will be -5 (a number)

		(C) Increment (++): The increment operator adds 1 to its operand. If placed before the operand (prefix increment), it increments the operand and then returns the incremented value. If placed after the operand (postfix increment), it returns the current value of the operand and then increments it.

    		var x = 5;
    		var y = ++x; // y will be 6, x will be 6

		(D) Decrement (--): The decrement operator subtracts 1 from its operand. Like the increment operator, if placed before the operand (prefix decrement), it decrements the operand and then returns the decremented value. If placed after the operand (postfix decrement), it returns the current value of the operand and then decrements it.

    		var x = 5;
    		var y = --x; // y will be 4, x will be 4

		(E) Logical Not (!): The logical NOT operator negates the boolean value of its operand. If the operand is true, it returns false; if the operand is false, it returns true.

    		var x = true;
    		var y = !x; // y will be false

		(F) Typeof Operator: The typeof operator returns a string indicating the type of the unevaluated operand.

    		var x = 5;
    		var y = typeof x; // y will be "number"

		Unary operators are essential in JavaScript for performing various operations on a single operand, such as converting types, changing signs, and checking truthiness or falsiness. Understanding how these operators work is crucial for effective JavaScript programming.

	(x) `,` Operator 
		
		(a) the comma operator (`,`) is a somewhat less commonly used operator that allows you to evaluate multiple expressions and return the value of the last expression. It evaluates each of its operands from left to right and returns the value of the rightmost operand.

		(b) Here's how the comma operator works:

			(I) `Evaluation Order`: The comma operator evaluates its operands sequentially, from left to right. Each operand can be any valid JavaScript expression.

			(II) `Return Value`: The comma operator returns the value of the rightmost operand after evaluating all the operands.

		(c) Examples:

			(I)

				const a = (2 + 3, 5 + 7); // The comma operator is used to separate two expressions
				console.log(a); // Output: 12 (the value of the rightmost expression)

				(A) In this example, `(2 + 3, 5 + 7)` is evaluated. The expression `2 + 3` is evaluated first, but its result is discarded because of the comma operator. Then, `5 + 7` is evaluated, and its value (12) is assigned to the variable `a`.
			
			(II)

				var x = 1, y = 2;
				(x++, y++); // The comma operator is used to increment both x and y
				console.log(x); // Output: 2
				console.log(y); // Output: 3

				(A) Here, the comma operator is used to increment both `x` and `y` by one. The expressions `x++` and `y++` are evaluated sequentially from left to right. The value of `x++` is discarded, and the value of `y++` (which is 3) is returned.

			(III)
				
				const a = (3 * 2, 'Hello', 5 + 7); // The comma operator is used to evaluate three expressions
				console.log(a); // Output: 12 (the value of the rightmost expression)

				In this case, `(3 * 2, 'Hello', 5 + 7)` is evaluated. The first expression `3 * 2` is evaluated but its value is discarded. Then, the string `'Hello'` is evaluated but its value is also discarded. Finally, `5 + 7` is evaluated and its value (12) is assigned to the variable `a`.

		(d) While the comma operator can be useful in certain contexts, it's often considered less readable and should be used judiciously to maintain code clarity. In most cases, it's clearer to use separate statements or expressions instead of relying on the comma operator for evaluation.

6. Comments

	(Note: Comment is a text in the Code which is Ingored by the Programm it can be used to navigate around you code)
	(i) To Comment any Text in the code put double slash at the very beginning of the line, something like this "//"
	(ii) if you're in VS Code then just select of any text of the line which you want to be commented and hold Control and hit slash (Ctrl + /)
	(iii) to Comment out text in which is Distributed in many lines put slash and a star "/*" at the very beginning of the line and then now come to very end of the last line now put a star and a slash "*/", every text on that area will be commented

7. Conditional Expressions

	(i) If Statements

		(a) "If" is used to run code with conditions for example if you use prompt with it and if a user has put a number into it will run the code according to it,for example if the user has put 4 then it will the first code or the user has put a different number then the code line of 2 will run
		(b) for example :-

			If(variable=1){
				alert("This is The First code")
			}
			If(variable=2){
				alert("This is The Second code")
			}
			
		(c) if you add "else if" statement after the "If" statement, if the test fails with 'if' statement then it'll check for a match in it, and also you can add them much as you want
		(d) if you add "else" in after the "If or else if" statement then if all the test fails then It'll run
		(d) The Code will look something like this:-
		
			let age =  prompt("What\'s Your Age?")
			age = Number.parseInt(age);
			if(age>18 && age<=100){
				alert("You\'re an Adult ")
			}
			else if(age<=18 && age>=13){
				alert("You\'re a Teenager")
			}
			else if(age<13 && age>=4){
				alert("You\'re a Kid")
			}
			else if(age<4 && age>0){
				alert("You\'re still a Baby")
			}
			else{
				alert("Invalid age")
			}

		(note: Do Not Put a Semicolumn";" after the if statement if you want to use else, but you can still use it inside the brackets)
		
	(ii) Switch Statement

		(a) `switch` statement allows you to check if value of a variable is equals to another value and execute a peice of Code:
		(b) Syntax:

			switch (<Variables>){
				case <value>:
					// code to execute if <Variables> === <value>
					break
				default:
					// Code to Execute If None of The Cases matches
			}

		(c) for Example:-
			
			let ticketCode = 24678

			switch(age){
				case 45184:
					console.log("You've won The First Prize!")
					break
				case 23567:
					console.log("You've won The Second Prize!")
					break
				case 98456:
					console.log("You've won The Third Prize!")
					break
				default:
					console.log("Sorry You Didn't won any Prizes")
					break
			}

8. Index
	
	(i) "index" typically refers to the position or numeric identifier used to access elements in an ordered collection, such as an array or a string. Understanding how indexing works in different contexts is important for efficient data retrieval and manipulation. Here's an explanation of indexing in JavaScript:

	(ii) String Indexing:

		(a) Strings are sequences of characters, and you can access individual characters in a string using numeric indices.
		You can access array elements by specifying the index within square brackets, like `string[index]`.

			const text = "Hello, World!";
			const firstCharacter = text[0]; // "H"

		(b) Strings are immutable in JavaScript, meaning you cannot directly change a character at a specific index. You need to create a new string with the desired modifications.

	(iii) Array Indexing:

		(a) Arrays are ordered collections of elements, and each element has a numeric index. The index starts at 0 for the first element, 1 for the second element, and so on.

			const fruits = ["apple", "banana", "cherry"];
			const secondFruit = fruits[1]; // "banana"
		
		(b) Be cautious when using array indices to avoid accessing elements that do not exist, which can lead to errors.

	(iv) Object Indexing (Property Access): 
		
		(a) In objects, properties can be accessed using keys, which are often strings, but they can also be symbols. These keys act as "indexes" for accessing object properties.
		
			const person = {
			    firstName: "John",
			    lastName: "Doe",
			};
			const firstName = person.firstName; // "John"

		(b) You can also use bracket notation to access object properties using a variable or an expression as the key.

			const key = "firstName";
			const value = person[key]; // "John"

	(v) Negative Indexing (Array Only):

		(a) In JavaScript arrays, you can use negative indices to count from the end of the array. `-1` refers to the last element, `-2` to the second-to-last, and so on.

			const numbers = [10, 20, 30, 40, 50];
			const lastNumber = numbers[-1]; // Gives: 50
			
		(b) Negative indexing is a convenient way to access elements from the end of an array without needing to know its length.

9. Loops

	(i) For Loops

		(a) for loops runs a specific peice of code over and over if a condition is met and does an operation

		(b) Syntax:

			for (<initial>; <condition>; <operation>){
				// code to run;
			}

			(I) <initial>: represents the iterator
			(II) <condition>: has to be met to execute the code inside it
			(III) <operation>: This operation has to be done on the <initial> value, to either increment or Decrement it's value

		Example:-

			/*	initialization | Condition | Operation
				(Runs Once)	   |		   | (Runs when The Interation is complete)
					↓				↓			↓*/
			for( let i = 0;		i < 10;			i++ ){
				console.log(i)
			}

			Console:

				0
				1
				2
				3
				4
				5
				6
				7
				8
				9
			
		(c) Iteration Over an Object

			(I) Syntax:

				for (let <initial> = 0; <initial> < Object.keys( <object> ).length; <initial>++){
					
					Object.keys(<object>)[<initial>] // <-- keys
					Object.values(<object>)[<initial>] // <-- values
					<object>[ Object.keys(<object>)[<initial>] ] // <-- This also Returns values
				}

			Example:-
			
				let score = {
				  	"player1": 89,
				  	"player2": 76,
				  	"player3": 54,
				  	"player4": 84,
				  	"player5": 91
				};

				for (let i = 0; i < Object.keys(score).length; i++){

				  	console.log("Score of " + Object.keys(score)[i] + " are " + Object.values(score)[i])
				}

		(c) Iteration Over A String

			(I) Syntax:

				for (let <initial> = 0; <initial> < <String>.length; <initial>++){
					
					<String>[<initial>] // returns the character of the Current Iteration
				}

			Example:-

				allwords = "The Quick Brown Fox Jumps over The Lazy dog"

				for (let i = 0; i < allwords.length; i++){
				  	console.log(allwords[i])
				}

				Console:

					T
					h
					e

					Q
					u
					i
					c
					k

					B
					r
					o
					w
					n

					F
					o
					x

					J
					u
					m
					p
					s

					o
					v
					e
					r

					T
					h
					e

					L
					a
					z
					y

					d
					o
					g

		(c) Iteration Over An Array

			(I) Syntax:

				for (let <initial> = 0; <initial> < <Array>.length; <initial>++){
					
					<Array>[<initial>] // returns the Value of the Current Iteration
				}

			Example:-

				arrayofwords = ["The", "Quick", "Brown", "Fox", "Jumps", "over", "The", "Lazy", "dog"]

				for (let i = 0; i < arrayofwords.length; i++){
				  	console.log(arrayofwords[i])
				}

				Console:

					The
					Quick
					Brown
					Fox
					Jumps
					over
					The
					Lazy
					dog
	
	(ii) For in Loops

		(a) For in Loops Shortens The Boilder Plate Code and makes it cleaner but with less control
		
		(b) Syntax:

			for(let <initial> in <iterator>){
				// Code to Execute
				<initial> // <-- Represents Keys if type is Object, if Array/string then The Iteration count,
				
				<iterator>[<initial>] // <-- Represents Values
			}

		(c) Example:

			// with Objects

			let scores = {
			  	player1: 87,
			  	player2: 56,
			  	player3: 43,
			  	player4: 67,
			  	player5: 96
			}
			for(let i in scores){
			  	console.log("Score of " + i + " is " + scores[i])
			}
			
			// with Arrays

			let scores = [ 87, 56, 43, 67, 96]
			for(let i in scores){
			  	console.log("Scores:", scores[i])
			}
			
			// with Strings

			words = "The Quick Brown Fox Jumps over The Lazy dog"

			for (let i in words){
			  	console.log(words[i])
			}

			Console:

				T
				h
				e

				Q
				u
				i
				c
				k

				B
				r
				o
				w
				n

				F
				o
				x

				J
				u
				m
				p
				s

				o
				v
				e
				r

				T
				h
				e

				L
				a
				z
				y

				d
				o
				g

	(iii) For of Loops

		(a) For of Loops are the same as `For-in` loops but it's built for Arrays and Strings only
			
		(b) Syntax:

			for(let <initial> in <iterator>){
				// Code to Execute
				<initial> // <-- Represents Values
				
			}

		(c) Examples:-

			// with Arrays

			let scores = [ 87, 56, 43, 67, 96]
			for(let i in scores){
			  	console.log("Scores:", i)
			}
			
			// with Strings

			words = "The Quick Brown Fox Jumps over The Lazy dog"

			for (let i in words){
			  	console.log(i)
			}
						
	(iv) While Loops
		
		(a) While Loop is Runs the Code inside it if the condition matches

		(b) Syntax:

			while(<condition>){
				// Code to run while the condition is true
			};

			(Note: In Syntax words that are inside angled brackets '<>' will be userDefined)

		Example :-

			a = 5
			b = 10

			while(a<=b){
			  	console.log(a);
			  	a++;
			};
			
			(WARNING: If the Condition doesn't becomes false it can lead to unintentional Infinite Loops)

			// An Example of Infinite Loop:

			while(true){
				// Runs Forever
			  	console.log('This Code runs Forever');
			};
				
	(v) Do While Loops

		(a) Do While Loops is a Variant of While loop but it runs the code atleasst once and then checks if the condition is true, if it's true then it runs it again
		
		(b) Example:-

			const b = 10
			let a = 2

			do{
				// Code here atleast runs once
			  	console.log(a);
			  	a++;
			}while(a<=b);
	
	(vi) Loop Controls

		(i) Loop controls in JavaScript are mechanisms used to manage the flow of iteration within loops. They allow you to alter the default behavior of loops, such as exiting a loop prematurely, skipping the current iteration, or restarting the loop from the beginning. Here are the main loop control statements in JavaScript:

		(ii) `break` Statement: The `break` statement is used to exit a loop prematurely, terminating the loop's execution. When a `break` statement is encountered within a loop, the loop immediately stops executing, and the program continues with the statement immediately following the loop.
		    
		    for (var i = 0; i < 5; i++) {
		        if (i === 3) {
		            break; // exit loop when i equals 3
		        }
		        console.log(i);
		    }
		    // Output: 0
		    //         1
		    //         2

		(iii) `continue` Statement: The `continue` statement skips the current iteration of the loop and proceeds with the next iteration. When a `continue` statement is encountered within a loop, the remaining code inside the loop for the current iteration is skipped, and the loop continues with the next iteration.

		    for (var i = 0; i < 5; i++) {
		        if (i === 2) {
		            continue; // skip iteration when i equals 2
		        }
		        console.log(i);
		    }
		    // Output: 0
		    //         1
		    //         3
		    //         4

		(iv) `return` Statement: Though not specific to loops, the `return` statement is used to exit a function. It also applies as a loop control if the loop is within a function. When a `return` statement is executed within a loop, it immediately exits both the loop and the function in which it is contained.

		    function findValue(array, value) {
		        for (var i = 0; i < array.length; i++) {
		            if (array[i] === value) {
		                return i; // exit function when value is found
		            }
		        }
		        return -1; // return -1 if value is not found
		    }

		(v) `label` and `break`/`continue`: JavaScript allows labeling loops so that you can break or continue specific loops nested within other loops. This is achieved by adding a label before the loop statement and using that label with `break` or `continue`.

			(A) Syntax:

				<LoopName>: <Loop>

		    outerLoop:
		    for (var i = 0; i < 3; i++) {
		        for (var j = 0; j < 3; j++) {
		            if (i === 1 && j === 1) {
		                break outerLoop; // exit outer loop when i equals 1 and j equals 1
		            }
		            console.log(i, j);
		        }
		    }
		    // Output: 0 0
		    //         0 1

		(vi) Loop controls provide flexibility and control over the flow of iteration in JavaScript loops, allowing you to handle special cases or conditions more effectively.

10. Funtions

	(i) Functions in JavaScript, often referred to as "traditional functions" or "function expressions," are a fundamental part of the language. They are used to define reusable blocks of code that can be executed when called. Function is a Block of code that is designed to perform a particular task, it can be used for code lines that are repeated, if you use this you just need to type the name of the funtion and round brackets with the variable'same

	(ii) JavaScript functions In General:

		(a) `Function Declaration`:

			function functionName(parameter1, parameter2) {
    			// Function body
    			// Code to be executed
			}

			(I) `functionName`: The name of the function. It's optional for anonymous functions (function expressions).
			
			(II) `parameter1, parameter2`: The parameters (inputs) that the function can accept. Parameters are optional, and you can also have none or infinite of them.

		(b) `Function Body`:

			(I) `the function body`, you write the code that the function will execute when it's called. You can perform calculations, manipulate data, and perform various tasks within the function.

				function add(a, b) {
    				return a + b;
				}

		(c) `Return Statement`

			(I) The return statement is used to specify the value that the function will produce as its result. If a function doesn't have a return statement, it will return undefined by default. A function can have multiple return statements, but once a return statement is executed, the function exits, and no further code within the function is executed.

				function add(a, b) {
    				return a + b;
				}

		(d) `Function Invocation (Calling)`:

			(I) To execute a function, you "call" it by using its name followed by parentheses containing the arguments (actual values) for its parameters (if any).

				function add(a, b) {
    				return a + b;
				}

				let result = add(3, 4);

			In this example, the add function is called with 3 and 4 as arguments, and it returns 7, which is assigned to the variable result.

		(e) Function Scope:
			
			(I) JavaScript functions have their own scope. Variables declared inside a function are local to that function and are not accessible outside of it unless explicitly returned.

				function exampleScope() {
				    let localVar = "I'm local!";
				    console.log(localVar); // Output: "I'm local!"
				}
				
				console.log(localVar); // Throws an error because localVar is not defined in this scope

		(f) Parameter Methods:

			(a) You can make a Function give a parameter a default value if the user doesn't provide it.

				function sayHello(name="World"){
					return "Hello, ${name}"
				}

				console.log(sayHello('John')) // Hello, John
				console.log(sayHello()) // Hello, World

			(b) You can make a Function take infinite Argument if you pass them as an Array.

				function AddNumbers(numbers){
					let Sum = 0;
					for(let i of numbers){
						Sum+=i
					}
					return Sum
				}

				console.log(AddNumbers([5,12,1]))

				// You can also Upgrade it Using `spread` operator

				function AddNumbers(...numbers){
					let Sum = 0;
					for(let i of numbers){
						Sum+=i
					}
					return Sum
				}

				console.log(AddNumbers(5,12,1)) // You don't have to put an extra bracket anymore

				(Note: If the Function takes more than 1 argument and one of them uses spread operator than make sure that it's the last argument)

				function AddNumbers(...numbers, contenttoprint){ // <-- This Throws an Error argument with the spread operator has to be the the last argument
					let Sum = 0;
					for(let i of numbers){
						Sum+=i
					}
					return Sum
				}

		(g) Documentation:

			(I) Documenting functions in JavaScript is essential for maintaining code readability and easing the process of collaboration among developers. One of the widely used standards for documenting JavaScript code is JSDoc. JSDoc is a markup language used to annotate JavaScript source code files, providing a clear description of how the code operates and helping to generate documentation websites. Here's a basic guide on how to document functions in JavaScript using JSDoc:

			(II) Syntax:

				/**
				* <Description of The Function>
				*
				* @<tag + it's syntax>
				*
				*/
				function sum(parameters) { // Some Function
					// Some code to run
				}

			(II) Basic Function Documentation: Begin with a description of what the function does. This is a simple comment block above the function. 

				/**
				* Calculates the sum of two numbers.
				*
				* @param {number} a The first number.
				* @param {number} b The second number.
				* @return {number} The sum of the two numbers.
				*/
				function sum(a, b) {
				  	return a + b;
				}

			(III) Parameters (@param): Use the `@param` tag to describe each parameter of the function. Include the type, name, and a brief description.

				* @param {<type>} <parameter> <description>

			(IV) Return Value (`@return` or `@returns`): Describe what the function returns using the `@return` or `@returns` tag. Include the type and a description of the return value.

				* @return {<type>} <description>
				* @returns {<type>} <description>

			(V) Data Types: Specify the data types for parameters and return values. Common types include `number`, `string`, `boolean`, `object`, `array`, etc.

			(VI) Optional Parameters and Default Values: If a parameter is optional or has a default value, document this as well.

				/**
				* Greet a user.
				*
				* @param {string} [name='Guest'] - The name of the user. Optional.
				* @return {string} A greeting message.
				*/
				function greet(name = 'Guest') {
				  	return `Hello, ${name}!`;
				}
				
			(VII) Function Examples: Including an example of how to use the function can be very helpful.

				/**
				* Calculates the sum of two numbers.
				*
				* @example
				* // returns 3
				* sum(1, 2);
				*
				* @param {number} a The first number.
				* @param {number} b The second number.
				* @return {number} The sum of the two numbers.
				*/
				function sum(a, b) {
				  return a + b;
				}

			(VIII) Throwing Exceptions: If your function throws errors or exceptions, use the `@throws` tag to describe the conditions under which this happens.

				/**
				* Divides two numbers.
				*
				* @param {number} a The numerator.
				* @param {number} b The denominator.
				* @return {number} The result of division.
				* @throws {Error} Throws error if the denominator is 0.
				*/
				function divide(a, b) {
				  	if (b === 0) {
				    	throw new Error("Cannot divide by zero.");
				  	}
				  	return a / b;
				}

			(IX) Async Functions and Promises: If the function returns a Promise or is an async function, document what the resolved value will be.

				/**
				* Fetches data from a given URL.
				*
				* @async
				* @param {string} url The URL to fetch data from.
				* @return {Promise<Object>} A promise that resolves with the fetched data.
				*/
				async function fetchData(url) {
				  	const response = await fetch(url);
				  	return response.json();
				}

	(iii) Arrow Functions

		(a) Arrow functions are commonly used for functions that don't require their own "this" context and are often used for callback functions, short anonymous functions, or simple one-liners.

			Here's the basic syntax of an arrow function:

			const functionName = (parameters) => {
    			// Function body
    			return result;
			};

		(b) `functionName`: The name of the function (optional). Arrow functions can be anonymous, or you can assign them to a variable as shown in the example.
		(c) `parameters`: The list of parameters the function accepts. If there's only one parameter, you can omit the parentheses around it.
		(d) `=>`: The arrow operator separates the parameter list from the function body.
		(e) `function body`: The code that gets executed when the function is called.
		(f) `result`: The value that gets returned from the function (optional). If the function body consists of a single expression, this expression's result will be returned automatically without needing an explicit return statement.

		Here are some examples to illustrate arrow functions:
		
		(g) A basic arrow function without parameters:

			const sayHello = () => {
    			console.log("Hello, World!");
			};
			
			sayHello(); // Outputs: Hello, World!

		(h) An arrow function with a single parameter:

			const square = (x) => {
    			return x * x;
			};

			console.log(square(5)); // Outputs: 25

		(i) An arrow function with a single expression (return statement is not required):

			const double = (x) => x * 2;
			console.log(double(4)); // Outputs: 8
			
		(j) Arrow functions in array methods like `map`:

			const numbers = [1, 2, 3, 4, 5];
			const squaredNumbers = numbers.map((x) => x * x);
			console.log(squaredNumbers); // Outputs: [1, 4, 9, 16, 25]

		(k) Using arrow functions as callback functions:

			const names = ["Alice", "Bob", "Charlie"];
			const nameLengths = names.map((name) => name.length);
			console.log(nameLengths); // Outputs: [5, 3, 7]

		(l) It's important to note that arrow functions have some differences compared to traditional function expressions:

			(I) Arrow functions do not have their own "this" context. They inherit the "this" value from their containing (enclosing) function or context. This behavior can be advantageous in certain situations but can also lead to unexpected results if not understood correctly.
			(II) Arrow functions cannot be used as constructors to create objects.			
			(III) Arrow functions are generally more concise and have a shorter syntax, which can make your code cleaner and easier to read for simple functions. However, for more complex functions or when you need access to the "this" context, traditional function expressions are still useful.

	Here's some built in Functions in JavaScript

	(iv) BigInt

	(v) `Boolean(<any>)`: returns a Boolean depending on The Input

		Cases:

		(a) <null> and <undefined>: Always Returns false

			console.log(Boolean(null)) // false
			console.log(Boolean(undefined)) // false

		(b) <Number> : Returns true unless 0

			console.log(Boolean(1)) // true
			console.log(Boolean(0)) // false
			console.log(Boolean(142)) // true
			console.log(Boolean(-5)) // true

		(c) <BigInt> : Returns true unless the coefficient is 0

			console.log(Boolean(142n)) // true
			console.log(Boolean(-5n)) // true
			console.log(Boolean(0n)) // false

		(d) <String> : Always Returns True

			console.log(Boolean('idk, what to write')) // true
		
		(e) <Symbol> : Always Returns True

			console.log(Boolean(Symbol("I don't wanna write this again"))) // true

	(vi) 'Math' Object

		(a) `Math.random()` : Generates a random floating-point number between 0 (inclusive) and 1 (exclusive).  example:-

			let randomNum = Math.random();

		(b) `Math.floor(<number>)` : Rounds a number DOWN to the nearest integer.  example:-

			let roundedDown = Math.floor(4.9); // 4

		(c) `Math.ceil(<number>)` : Rounds a number UP to the nearest integer.  example:-
			
			let roundedUp = Math.ceil(2.1); // 3

		(d) `Math.round(<number>)` : Rounds a number TO the nearest integer.  example:-
			
			let rounded = Math.round(3.5); // 3

		(e) `Math.max(...numbers)` : Returns the largest number from a list of arguments. 
			
			let largest = Math.max(5, 10, 2); // 10

		(f) `Math.min(...numbers)` : Returns the smallest number from a list of arguments.  example:-
			
			let smallest = Math.min(5, 10, 2); // 2

		(g) `Math.sqrt(number)`: Returns Square Root of The Number;

			console.log(Math.sqrt(5)) // 2.23606797749979

		(g) `Math.PI`: Returns Value of PI;

			console.log(Math.PI) // 3.141592653589793

	(vii) `Number`:

		(a) Function:

			Cases
			
			(I) <null>: Returns 0

				console.log(Number(null)) // 0

			(II) <BigInt>: Return It as a Number

				console.log(Number(143n)) // 143

			(III) <Boolean>: true = 1, false = 0

				console.log(Number(true)); // 1
				console.log(Number(false)); // 0

			(IV) <String>: Return it as a Number only if it doesn't contain anything else other than a Valid Integer

				console.log(Number('568')); // 568
				console.log(Number('121fs')); // Error

			(IV) Doesn't accepts <undefined> and <Symbol>

		(b) Object:

			(I) `parseInt(<Float, BigInt, String>)` :"Converts a string to an integer." example:-

				Cases:

				(A) <Float> (Decimal): Rounds to The nearest Integer

					console.log(parseInt(11.8)) // 12 
					console.log(parseInt(11.5)) // 11 
					console.log(parseInt(11.3)) // 11

				(B) <BigInt>: Return It as a Number

					console.log(Number(143n)) // 143

				(C) <String>:

					console.log(parseInt('12')) // 12
					
					console.log(parseInt('12 this')) // 12 , return the number part of the string and 
					ignores the rest without throwing an error

					console.log(parseInt('this 12')) // NaN

			(II) `parseFloat(<string>)`: "Converts a string to a floating-point number." example:-
		
				console.log(parseFloat("3.14")); // 3.14

	(viii) `String`

		(a) `String(<value>)` :"Converts any value to a string." example:-

			console.log(String(null)) 		// 'null'
			console.log(String(148)) 		// '148'
			console.log(String(1252n)) 		// '1252n'
			console.log(String(true)) 		// 'true'
			console.log(String(Symbol(1))) 	// 'Symbol(1)'
			console.log(String(undefined)) 	// 'undefined'

		(b) `String.toUpperCase()` and `toLowerCase()`: makes all of the characters in The String Lowercase/Uppercase.

			let lowercase = "hello";
        	let uppercase = "HELLO";
        	let uppercase = lowercase.toUpperCase();
        	let lowercase = uppercase.toLowerCase();

		(c) `String.slice()`: extract a portion of a string or an array and creates a new one. It takes one or two arguments: the starting and ending index (the ending index is optional). The function returns a new string or array containing the elements from the original that fall within the specified range.

			const text = "Hello, World!";
			const sliced = text.slice(0, 5); // Extracts "Hello"

			(Note: It takes Index and Index starts from '0' instead of '1')

		(d) `String.replace(<>, replacement)`: "Replaces a substring with another substring."
			
            console.log("Hello, world!".replace("world", "Universe")) // Hello, Universe!

		(e) `String.concat(string)`: "Combines two or more strings."
			
            let str1 = "Hello";
            let str2 = "world";
            let combined = str1.concat(", ", str2);

		(f) `String.split(separator)`: "Splits a string into an array of substrings."
			
            let sentence = "This is a sentence.";
            let words = sentence.split(" ");
			
		(g) `String.includes(substring)`: "Checks if a substring is present in a string."

			let text = "Hello, world!";
            let hasHello = text.includes("Hello");

		(h) `String.substr():` works the same as `String.slice()`

	(ix) `Symbol`

	(x) 'Array'
		
		(a) `concat()` : "Concatenates two or more arrays and returns a new array."

		   Example: 
		   const array1 = [1, 2, 3];
		   const array2 = [4, 5, 6];
		   const concatenatedArray = array1.concat(array2);
		   console.log(concatenatedArray); // Output: [1, 2, 3, 4, 5, 6]

		(b) `push()` : "Adds one or more elements to the end of an array and returns the new length of the array."

		   Example: 
		   const fruits = ["apple", "banana"];
		   const newLength = fruits.push("cherry");
		   console.log(fruits); // Output: ["apple", "banana", "cherry"]
		   console.log(newLength); // Output: 3

		(c) `pop()` : "Removes the last element from an array and returns that element."

		   Example: 
		   const fruits = ["apple", "banana", "cherry"];
		   const removedFruit = fruits.pop();
		   console.log(fruits); // Output: ["apple", "banana"]
		   console.log(removedFruit); // Output: "cherry"

		(d) `shift()` : "Removes the first element from an array and returns that element."
   
		   Example: 
		   const fruits = ["apple", "banana", "cherry"];
		   const removedFruit = fruits.shift();
		   console.log(fruits); // Output: ["banana", "cherry"]
		   console.log(removedFruit); // Output: "apple"

		(e) `unshift()` : "Adds one or more elements to the beginning of an array and returns the new length of the array."

		   Example: 
		   const fruits = ["banana", "cherry"];
		   const newLength = fruits.unshift("apple");
		   console.log(fruits); // Output: ["apple", "banana", "cherry"]
		   console.log(newLength); // Output: 3

		(f) `splice()` : "Changes the contents of an array by removing, replacing, or adding elements."

		   Example code to remove elements:
		   const fruits = ["apple", "banana", "cherry", "date"];
		   fruits.splice(1, 2); // Removes 2 elements starting from index 1
		   console.log(fruits); // Output: ["apple", "date"]

		   Example code to add elements:
		   const fruits = ["apple", "date"];
		   fruits.splice(1, 0, "banana", "cherry"); // Adds "banana" and "cherry" at index 1
		   console.log(fruits); // Output: ["apple", "banana", "cherry", "date"]

		(g) `slice()` : "Returns a shallow copy of a portion of an array into a new array object selected from start to end." for example:- 

	   		const fruits = ["apple", "banana", "cherry", "date"];
	   		const slicedFruits = fruits.slice(1, 3); // Returns elements at index 1 and 2
	   		console.log(slicedFruits); // Output: ["banana", "cherry"]

			`Array.isArray(array)` :"Checks if a given value is an array." example:-

			let arr = [1, 2, 3]; 
			Array.isArray(arr); 
			// Returns true

	(xi) `typeof(variable)` :"Returns a string indicating the data type of a variable." example:-

		let type = typeof("Hello");
			
	(xii) `Date()` Function and It's similar ones:

		(a) `Date()` function in JavaScript is used for creating instances that represent a single moment in time. It enables you to work with dates and times in your applications. Here's a brief overview of the `Date()` function and related methods:

		(b) Creating a Date Object: You can create a `Date` object using the `new` keyword. If no argument is provided, it returns the current date and time.

			const currentDate = new Date();

		(c) Date Methods:

			(I) `getFullYear()`: Returns the year of the specified date according to local time.
			(II) `getMonth()`: Returns the month (0-11) in the specified date according to local time.
			(III) `getDate()`: Returns the day of the month (1-31) for the specified date according to local time.
			(IV) `getDay()`: Returns the day of the week (0-6) for the specified date according to local time.
			(V) `getHours()`, `getMinutes()`, `getSeconds()`, `getMilliseconds()`: Returns the respective components of the time.

		(d) Formatting Dates:

			(I) `toDateString()`: Converts the date portion of a `Date` object into a readable string.
			(II) `toTimeString()`: Converts the time portion of a `Date` object into a readable string.

		(e) Parsing and Conversion:

			(I) `Date.parse()`: Parses a string representation of a date and returns the number of milliseconds since January 1, 1970.
			(II) `toISOString()`: Returns a string in simplified extended ISO format.

		(f) Manipulating Dates:

			(I) `setFullYear()`, `setMonth()`, `setDate()`: Sets the respective components of the date.
			(II) `setHours()`, `setMinutes()`, `setSeconds()`, `setMilliseconds()`: Sets the respective components of the time.

		(g) Date Arithmetic:

			(I) `getTime()`: Returns the number of milliseconds between January 1, 1970, and the specified date.
			(II) `setTime()`: Sets the Date object to the time represented by a number of milliseconds since January 1, 1970.

		(h) Examples:-

			(I) Creating a `Date` object and retrieving various components:

				const currentDate = new Date();

				currentDate.getFullYear(); // Current year
				currentDate.getMonth(); // Current month (0-11)
				currentDate.getDate(); // Current day of the month
				currentDate.getDay(); // Current day of the week (0-6)
				currentDate.getHours(); // Current hour
				currentDate.getMinutes(); // Current minute
				currentDate.getSeconds(); // Current second

			(II) Formatting and parsing dates:

				const dateString = currentDate.toDateString();
				const timeString = currentDate.toTimeString();
				
				console.log(dateString); // Convert date portion to a string
				console.log(timeString); // Convert time portion to a string
				
				const parsedDate = Date.parse('Aug 9, 1995');
				console.log(parsedDate); // Number of milliseconds since January 1, 1970
				
			(III) Manipulating dates:

				currentDate.setFullYear(2022); // Set year to 2022
				currentDate.setMonth(10); // Set month to November (zero-based)
				currentDate.setDate(15); // Set day of the month to 15

				currentDate.setHours(12); // Set hour to 12
				currentDate.setMinutes(30); // Set minute to 30
				currentDate.setSeconds(45); // Set second to 45

				console.log(currentDate.toDateString()); // Display the updated date
				console.log(currentDate.toTimeString()); // Display the updated time

			(IV) Date arithmetic:

				const milliseconds = currentDate.getTime(); // Number of milliseconds since Jan 1, 1970
				console.log(milliseconds);

				const futureDate = new Date();
				futureDate.setTime(milliseconds + 86400000); // Add 1 day (in milliseconds) to the current date
				
				console.log(futureDate.toDateString());

	(xiii) Functions of Console

		(a) `console.log(message)`: Logs a message to the console. for Example:-

			console.log("Hello, world!");

		(b) `console.info(message)`: Logs an informational message to the console. for Example:-

			console.info("'C' opens chat");

		(c) `console.warn(message)`: Logs a warning message to the console. for Example:-

			console.warn("Warning: You're entering Dangerous Zone!");

		(d) `console.error(message)`: Logs an error message to the console. for Example:-

			console.error("An error occurred!");

		(e) `console.clear()`: Clears the console, removing all previous messages. for Example:-

			console.clear();

		(f) `console.table(data, columns)`: Displays tabular data in a table format. for Example:-

			const data = [
  				{ name: "John", age: 30 },
  				{ name: "Alice", age: 25 },
			];

			console.table(data);

		(g) `console.group(label)` and `console.groupEnd()`: Groups log messages together with a common label. for Example:-

			console.group("Intro");
			console.log("Hello!");
			console.log("My names's ...");
			console.groupEnd();

		(h) `console.count(label)`: Counts the number of times `console.count()` is called with the same label. for Example:-

			console.count("Clicks");
			console.count("Clicks");

		(i) `console.time(label)` and `console.timeEnd(label)`: Measures the time elapsed between console.time and console.timeEnd calls with the same label. for Example:-

			console.time("Timer");
			// Some code to measure
			console.timeEnd("Timer")

		(j) `console.assert(condition, message)`: Checks a condition and logs a message to the console if the condition is false. for Example:-

			console.assert(2 + 2 === 5, "Math is broken!"); // Logs the message

		(k) `console.dir()`: Displays an interactive list of an object's properties in the console. It allows you to explore the object's structure (Including HTML Elements).

			const person = { name: "John", age: 30 };
			console.dir(person);		

	(xiv) `Prompt/Alert/Confirm` Functions:

		(a) `prompt(message, defaultValue)` :"It's used to display a dialog box that prompts the user to enter some input. It takes two arguments:-

			(I) message: The message to display to the user, typically instructing them on what to enter.
			(II) DefaultValue (optional): The default value pre-filled in the input field.

			for example:

				let userInput = prompt("Please enter your name:", "John Doe");

				(A) In this example, a dialog box will appear with the message "Please enter your name:" and an input field pre-filled with "John Doe." The user can enter their name, and the input will be stored in the userInput variable.

			(III) `prompt()` returns the text entered by the user as a string or null if the user clicks "Cancel" or closes the dialog.

		(b) `alert(message)` :"alert() is used to display a simple message to the user in a dialog box. It typically contains an "OK" button to close the dialog." for example:-

			alert("Hello, World!");

			(I) The above code will display a dialog box with the message "Hello, World!" and an "OK" button. It's commonly used for displaying informative messages to users.

		(c) `confirm(message)` :" : Displays a message in a confirm dialog with "OK" and "Cancel" buttons." for example:-

			let result = confirm("Are you sure?");


			// Display an alert message
			alert("This is an alert!");

			// Show a confirmation dialog
			const result = confirm("Are you sure?");

	(xv) Timeout Functions

		(a) `setTimeout()`: This function executes a specified function or a specified piece of code 'ONCE' after a specified delay. It takes two main arguments: a function or a piece of code to execute and the delay time in milliseconds before the execution. Optionally, it can take additional arguments that will be passed to the function. for Example:-

			let timeoutID = setTimeout(() => {
			    console.log('Delayed log after 2 seconds');
			}, 2000);
			console.log(timeoutID) // Returns The ID of The Timeout which is essential to Terminate Timeouts later on

			Addition Arguments Example:-

			const sum = (a, b, c)=>{
            	console.log(a+b+c)
        	};
        	const timeoutID1 = setTimeout(sum, 5000, 5, 3, 2); //argument after the second argument will be passed to the function
			// outputs: 10

		(b) `setInterval()`: This function 'REPEATEDLY' executes a specified function or a specified piece of code at a specified time interval. It also takes two main arguments: a function or a piece of code to execute and the time interval in milliseconds between each execution. Like `setTimeout()`, it can also take additional arguments.

			let count = 0;

			let intervalTimeoutID = setInterval(() => {

			    count++;
			    console.log('Interval log:', count);

			    if (count >= 5) {
			        clearInterval(intervalTimeoutID); // Stop the interval after 5 executions
			    }

			}, 1000);

			console.log(intervalTimeoutID)

		(c) You can Terminate any scheduled timeout by using `clearTimeout()` and `clearInterval()`, respectively and They requires ID of the Timeout which is stored inside the variable which is running the Timeout.

		(Note: The variable which is running The Timeout Function contains The ID of The Timeout)
	
11. Arrays
	
	(note: Array is an not a primitive data type it's an Object)
	(i) Array can hold Multiple Values at Once 
	(ii) This is an array, It can be used by using square brackets

		let a = [87, 76, 96, 67, 98];

	(iii) `<array>[<index>]` returns the value at that index:

		let a = [87, 76, 96, 67, 98];
		a[0] // 87
		a[1] // 76

	(iv) `<array>.length` returns Amount of Items inside The Arrau
	(iv) To add a new value to the array type "a[index] = value", or just put the index of an existing one to change the value
	(v) Array Functions
	
		(a) `Array.length` returns amount of values in the array
		(b) `Array.toString()` returns array as a String			
		(c) `Array.join()` returns a new string by concatenating all of the elements in this array, separated by commas or a specified separator string. If the array has only one item, then that item will be returned without using the separator.
		(d) `Arrat.pop()` method of Array instances removes the last element from an array and returns that element. This method changes the length of the array.

			const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];

			console.log(plants.pop());
			// Expected output: "tomato"

			console.log(plants);
			// Expected output: Array ["broccoli", "cauliflower", "cabbage", "kale"]

			plants.pop();

			console.log(plants);
			// Expected output: Array ["broccoli", "cauliflower", "cabbage"]

		(e) `Array.push("value")` adds the specified elements to the end of an array and returns the new length of the array.

			const animals = ['pigs', 'goats', 'sheep'];

			const count = animals.push('cows');
			console.log(count);
			// Expected output: 4
			console.log(animals);
			// Expected output: Array ["pigs", "goats", "sheep", "cows"]

			animals.push('chickens', 'cats', 'dogs');
			console.log(animals);
			// Expected output: Array ["pigs", "goats", "sheep", "cows", "chickens", "cats", "dogs"]

		(f) `Array.concat(array1)` merges two or more arrays. This method does not change the existing arrays, but instead returns a new array.

			const array1 = ['a', 'b', 'c'];
			const array2 = ['d', 'e', 'f'];
			const array3 = array1.concat(array2);

			console.log(array3);
			// Expected output: Array ["a", "b", "c", "d", "e", "f"]

		(g) `Array.sort()` method of Array instances sorts the elements of an array in place and returns the reference to the same array, now sorted. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values. 

			const months = ['March', 'Jan', 'Feb', 'Dec'];
			months.sort();
			console.log(months);
			// Expected output: Array ["Dec", "Feb", "Jan", "March"]

			const array1 = [1, 30, 4, 21, 100000];
			array1.sort();
			console.log(array1);
			// Expected output: Array [1, 100000, 21, 30, 4]
		
		(h) `Array.reverse()` method of Array instances reverses an array in place and returns the reference to the same array, the first array element now becoming the last, and the last array element becoming the first. In other words, elements order in the array will be turned towards the direction opposite to that previously stated.

			const array1 = ['one', 'two', 'three'];
			console.log('array1:', array1);
			// Expected output: "array1:" Array ["one", "two", "three"]

			const reversed = array1.reverse();
			console.log('reversed:', reversed);
			// Expected output: "reversed:" Array ["three", "two", "one"]

			// Careful: reverse is destructive -- it changes the original array.
			console.log('array1:', array1);
			// Expected output: "array1:" Array ["three", "two", "one"]

		(k) `Array.slice()` returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.
			
			const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

			console.log(animals.slice(2));
			// Expected output: Array ["camel", "duck", "elephant"]

			console.log(animals.slice(2, 4));
			// Expected output: Array ["camel", "duck"]

			console.log(animals.slice(1, 5));
			// Expected output: Array ["bison", "camel", "duck", "elephant"]

			console.log(animals.slice(-2));
			// Expected output: Array ["duck", "elephant"]

			console.log(animals.slice(2, -1));
			// Expected output: Array ["camel", "duck"]

			console.log(animals.slice());
			// Expected output: Array ["ant", "bison", "camel", "duck", "elephant"]

			(I) You can also provide arguments after the 2nd argument to replace the selected items inside the array with the values of the arguments after the 2nd second argument
			
		(l) `Array.from()` static method creates a new, shallow-copied Array instance from an iterable or array-like object.

			console.log(Array.from('foo'));
			// Expected output: Array ["f", "o", "o"]

			console.log(Array.from([1, 2, 3], (x) => {
				x + x
			}));
			// Expected output: Array [2, 4, 6]

			(I) Syntax:

				Array.from(arrayLike)
				Array.from(arrayLike, mapFn)
				Array.from(arrayLike, mapFn, thisArg)

			(II) Parameters:

				(A) `arrayLike`: An iterable or array-like object to convert to an array.
				(B) `mapFn` (Optional): A function to call on every element of the array. If provided, every value to be added to the array is first passed through this function, and mapFn's return value is added to the array instead

					I. element: The current element being processed in the array.
					II. index: The index of the current element being processed in the array.

				(C) `thisArg` (Optional): Value to use as `this` when executing 	.

		(m) `find()`: finds the first element in the array that matches the specific condition and returns it's value using an conditional function. for example:-

			const numbers = [5, 12, 8, 130, 44];

			const found = numbers.find(function(element) {
			  return element > 10;
			});

			console.log(found); // Output: 12

	(vi) For Loops

		(a) "For Loops" is mostly the exact same as it's for other but If you want to use it just change for this:-
			
			for(let i = 0; i<num.length; i++){
				console.log(i)
			}
			
			To This
			
			for(let i = 0; i<num.length; i++){
				console.log(num[i])
			}

			// (note: Only the content inside the round brackets which is right after the "console.log", is the one changed so keep in mind)
			
	(vii) For Each

		(a) `forEach(callback[, thisArg])` : "Iterates over each element in the array and executes a provided callback function for each element."
		(b) It's an array method that executes a provided callback function once for each element in the array in ascending order.
		(c) The callback function takes up to three arguments: `currentValue`, `currentIndex`, and the array `array` itself. However, typically, only currentValue is used.

			numbers.forEach((value, index, array) => {});

		(d) It's a way to perform an action on each item in the array without the need for explicit loops like for or while.
		(e) The optional `thisArg` parameter can be used to set the value of this within the callback function
		
		Example:-

			const numbers = [1, 2, 3, 4];
			numbers.forEach((number) => {
    			console.log(number * 2);
			});
		
		Here's another example where all perimeters are getting used:-

			const colors = ['red', 'green', 'blue'];
			colors.forEach(function(currentValue, currentIndex, array) {
			    console.log(`Color at index ${currentIndex}: ${currentValue}`);
			});

			// Output:
			// Color at index 0: red
			// Color at index 1: green
			// Color at index 2: blue
			
			In this example:

				`currentValue` represents the current element in the array (colors).
				`currentIndex` represents the index of the current element.
				`array` represents the original array (colors).

	(viii) Map

		(a) "Map" is same as "ForEach" but instead of making an operation it creates a new array. here's the example code for it:-

			let a = array.map((value)=>{
				console.log(value *2)
			})

	(ix) Filter

		(a) `filter(callback[, thisArg])` : "Creates a new array containing all elements from the original array that satisfy a provided testing function (callback)."
		(b) `filter()` is an array method that creates a new array by iterating over each element of the original array.
		(c) It applies a provided callback function to each element.
		(d) Elements that meet the criteria specified in the callback function are included in the new array, while those that don't meet the criteria are excluded.
		(e) The optional thisArg parameter allows you to set the value of this within the callback function.
		
		Example:-

			const numbers = [1, 2, 3, 4, 5, 6];
			const smaller_numbers = numbers.filter((number) => {
			    return number<5;
			});
			console.log(smaller_numbers); // Output: [1, 2, 3, 4]

			In the example, filter() is used to create a new array `smaller_numbers` containing only the numbers smaller than 5 from the `numbers` array.

	(x) Reduce
		
		(a) `reduce(callback[, initialValue])` : "Applies a provided callback function to each element of an array, accumulating the results into a single value. The `reduce` function is used to transform an array into a single value, such as a sum, average, or concatenated string."
		(b) `reduce()` is an array method that iterates over each element of the array, applying a callback function to accumulate the values into a single result. for Example:-

			const numbers = [1, 2, 3, 4, 5];
			const sum = numbers.reduce((accumulator, currentValue) => {
			    return accumulator + currentValue;
			}, 0);
			console.log(sum); // Output: 15

Section: JavaScript in Browser (Client Side)

12. `Window` Object

	(i) The `window` object is a fundamental object in JavaScript that represents the browser `window` or the global context in which your JavaScript code is executed when running in a web browser environment. It provides access to various properties and methods related to the browser and the document being displayed. The window object is the global object in a browser environment. This means that variables and functions declared in the global scope are properties and methods of the window object. For example, if you declare a variable `x` in the global scope, it becomes `window.x` You can write it any way you want

		let x = 42;
		console.log(window.x); // Outputs: 42

	(ii) window Object: The window object is the top-level object of the BOM. It represents the browser window or tab and serves as the global object for JavaScript in the browser. You can access properties and methods related to the browser through this object.

		// Accessing the browser's location
		console.log(location.href);

		// Opening a new browser window
		window.open("https://www.example.com");

	and 'Window' object also contains

	(ii) Core of JavaScript
	(iii) Document Object Model (DOM)
	(iv) Browser Object Model

13. DOM

	(i) The Document Object Model (DOM) is a programming interface for web documents. It represents the page so that programs can change the document structure, style, and content dynamically. The DOM represents the document as a tree of objects where each object corresponds to a part of the page, such as elements, attributes, and text. It provides a structured way to interact with and manipulate web content using programming languages like JavaScript.

	Here are some key aspects and functions of the DOM:

	(ii) Document Structure Representation: The DOM represents an HTML or XML document as a tree structure of nodes. Each node corresponds to an element, attribute, or text content within the document. The top node is called the `document` node, representing the entire document.

	(iii) Traversal functions
		
		(a) Traversal functions are methods that allow you to navigate the DOM tree by moving between different elements or nodes. These functions are essential for selecting specific elements or nodes based on their relationships to other elements. Common DOM traversal functions include:
		
		(b) `parentNode`: This property allows you to access the parent element of a given node. You can use it to move up the DOM tree one level.

			const childElement = document.getElementById("child");
			const parentElement = childElement.parentNode;

		(c) `childNodes`: This property returns a collection of all child nodes (including elements, text nodes, and comments) of a given element. You can use it to access and iterate through the children of an element.

			const parentElement = document.getElementById("parent");
			const childNodes = parentElement.childNodes;

		(d) `firstChild` and `lastChild`: These properties allow you to access the first and last child nodes of an element, respectively.

			const parentElement = document.getElementById("parent");
			const firstChild = parentElement.firstChild;
			const lastChild = parentElement.lastChild;

		(e) `firstElementChild` and `lastElementChild`: These properties allow you to access the first and last child of an element, respectively, It's similar to `firstChild` and `lastChild` property but it only targets Element Nodes not any type of nodes.

			const parentElement = document.getElementById("parent");
			const firstChild = parentElement.firstElementChild;
			const lastChild = parentElement.lastElementChild;

		(f) `nextSibling` and `previousSibling`: These properties allow you to access the next and previous sibling nodes of an element, respectively.

			const element = document.getElementById("current");
			const nextSibling = element.nextSibling;
			const previousSibling = element.previousSibling;

		(g) `nextElementSibling` and `previousElementSibling`: These properties are similar to `nextSibling` and `previousSibling`, but they specifically target the next and previous sibling elements (HTML elements) rather than any type of node. (recommended)

			const element = document.getElementById("current");
			const nextElementSibling = element.nextElementSibling;
			const previousElementSibling = element.previousElementSibling;

		(Note: You can These properties over-and-over to get your element, for example if you've selected an element and you want to get an element which is inside another element which inside the currect element then you can use the `firstElementChild` property over-and-over)
			
		(h) `querySelector` and `querySelectorAll`: These methods allow you to select elements within the DOM tree using CSS-style selectors. You can use them to find elements based on their attributes, classes, or other properties.

			const elements = document.querySelectorAll(".myClass");
			const singleElement = document.querySelector("#myId");

	(iv) Table Navigation

		(a) Table navigation in typically involves traversing the rows and cells of an HTML table and interacting with them dynamically. You can achieve table navigation using various DOM methods and properties. 
		
		Here's an overview of how you can navigate and manipulate tables in :-

		Accessing the Table Element:

		(b) First, you need to obtain a reference to the HTML table element. You can do this using the document.`getElementById`, `document.querySelector`, or similar DOM methods, depending on how your table is defined in the HTML.
			
			const table = document.getElementById("myTable");

		(c) Accessing Rows and Cells: Once you have a reference to the table, you can access its rows and cells using properties and methods like `rows`, `insertRow`, `deleteRow`, `cells`, etc.

			(I) You can access rows using various methods in JavaScript, such as `getElementById`, `querySelector`, or by using the table's rows collection. Here's how you can access the rows:-

				// Using getElementById (assuming you have set the "id" attribute on your table)
				const table = document.getElementById("myTable");
				const rows = table.getElementsByTagName("tr");

				// Using querySelector to select the table and then the rows
				const table = document.querySelector("#myTable");
				const rows = table.querySelectorAll("tr");

				// Using the rows collection directly
				const table = document.getElementById("myTable");
				const rows = table.rows; // This is a collection of all the rows in the table

				(Note: You can access tags inside the element You've selected by putting the tag-name of the child element, and you can do that as many times as you want)

		(d) Iterating Through Rows and Cells: You can use loops to iterate through the rows and cells of the table. Common loops include `for`, for...of, and `forEach`.

			// Iterate through all rows
			for (let i = 0; i < table.rows.length; i++) {
			    const row = table.rows[i];
			    // Iterate through cells in the current row
			    for (let j = 0; j < row.cells.length; j++) {
			        const cell = row.cells[j];
			        // Perform actions with the cell content
			    }
			}

		(e) Modifying Table Data: You can update the content of table cells or rows by modifying the `textContent` or `innerHTML` property of the respective cell.

			cell.textContent = "New Value";

		(f) Adding and Removing Rows: You can add new rows to the table using the insertRow method and remove rows using the `deleteRow` method.

			// Add a new row at the end of the table
			const newRow = table.insertRow();

			// Remove a specific row
			table.deleteRow(1);
			
		(g) Creating and Appending Elements: You can dynamically create HTML elements (e.g., `<tr>`, `<td>`) and append them to the table using methods like `createElement` and `appendChild`.

			const newRow = document.createElement("tr");
			const newCell = document.createElement("td");
			newCell.textContent = "New Cell";
			newRow.appendChild(newCell);
			table.appendChild(newRow);

	(v) Document Object

		The `Document` object is a fundamental part of the Document Object Model (DOM) in JavaScript. It represents the web page or document displayed in a web browser and provides methods and properties to interact with and manipulate the content and structure of the document. The Document object serves as the entry point to the DOM tree and allows you to access and modify elements, attributes, and text within the document. Here are some key aspects and functions of the Document object:
		
		DOM Tree: "https://www.w3schools.com/js/pic_htmltree.gif"

		(a) Accessing Elements:

			(I) `getElementById(id)`: Returns the element with the specified id attribute.

				let element = document.getElementById("myElement");
				
				(a) If you gave your element an id then most of the Modern Browser provides you that Element in a variable with the name of your id for example:-

					HTML:

						<div id="box"></div>
					
					JS:

						console.log(box) // returns the Element with the id 'box'

					(Note: It's important to Note that it depends on browser However most the modern browsers supports it but some may not, so Consider using The Function Method Instead so the user won't face any Problems.)

			(II) `getElementsByClassName(className)`: Returns a collection of elements with the specified class name.

				let elements = document.getElementsByClassName("myClass");

				(Note: It requires an Index Value to select an element in the collection even if it's just one, If you wanna edit all of them you have to run a Loop for each of them)

			(III) `getElementsByTagName(tagName)`: Returns a collection of elements with the specified tag name.

				let paragraphs = document.getElementsByTagName("p");

			(IV) `querySelector(selector)`: Returns the first element that matches the specified CSS selector.

				let firstDiv = document.querySelector("div");

			(V) `querySelectorAll(selector)`: Returns a collection of elements that match the specified CSS selector.

				let allLinks = document.querySelectorAll("a");

			(Note: The arguments of `querySelector(selector)` and `querySelectorAll(selector)` should be same as CSS selecter means you can put something like this as the argument: ".myclass" or "#myelement")

		(b) Creating and Modifying Elements:

			(I) `createElement(tagName)`: Creates a new element with the specified tag name.

				let newDiv = document.createElement("div");

			(II) `appendChild()`: This method is used to add a node to the end of the list of children of a specified parent node.

				const parentElement = document.getElementById('parent');
				const newChild = document.createElement('p');
				parentElement.appendChild(newChild);

			(III) `prepend()` function is used to insert a set of specified elements or nodes at the beginning of the target element. This allows you to prepend content to the beginning of an element.

				const parent = document.getElementById('parentElement');
				const newElement = document.createElement('p');
				const textNode = document.createTextNode('This is prepended content.');
				newElement.appendChild(textNode);
				parent.prepend(newElement);

			(IV) `replaceChild()`: This method replaces a child node within a specified parent node with a new node.

				const parentElement = document.getElementById('parent');
				const newChild = document.createElement('p');
				const oldChild = document.getElementById('oldChild');
				parentElement.replaceChild(newChild, oldChild);
				
			(V) `removeChild(node)`: Removes a child node from its parent node.

				let childElement = document.getElementById("child");
				parentElement.removeChild(childElement);

			(VI) `after()`: Inserts HTML content or elements after the specified element. It adds content or elements as a sibling immediately following the target element.

				const targetElement = document.getElementById('targetElement');
				const newElement = document.createElement('p');
				newElement.textContent = 'This is inserted after the target element';
				targetElement.after(newElement);

			(VII) `before()` inserts HTML content or elements before the specified element. It adds content or elements as a sibling immediately preceding the target element.

				const targetElement = document.getElementById('targetElement');
				const newElement = document.createElement('p');
				newElement.textContent = 'This is inserted before the target element';
				targetElement.before(newElement);

			(VIII) `replaceWith()` replaces an element in with one or more new elements. It removes the specified element and inserts the new elements in its place.

				const oldElement = document.getElementById('oldElement');
				const newElement = document.createElement('p');
				newElement.textContent = 'This is the new element replacing the old one.';
				oldElement.replaceWith(newElement);

				(A) In this example, the `replaceWith()` function replaces the `oldElement` with the newly created `newElement`. The contents of `oldElement` are entirely replaced with the contents of `newElement`, effectively updating the DOM structure.
				
			(IX) `insertAdjacentHTML/Element/Text` Functions:-

				(A) `insertAdjacentHTML()`: This method allows you to insert HTML at a specified position relative to the element invoking the method. You can specify positions such as 'beforebegin', 'afterbegin', 'beforeend', and 'afterend'.

					const element = document.getElementById('target');
					element.insertAdjacentHTML('afterend', '<p>This is inserted after the target element</p>');

				(B) `insertAdjacentElement()`: This method is similar to insertAdjacentHTML(), but it allows you to insert a DOM element instead of HTML text.

					const element = document.getElementById('target');
					const newElement = document.createElement('p');
					newElement.textContent = 'New element';
					element.insertAdjacentElement('afterend', newElement);

				(C) `insertAdjacentText()`: This method allows you to insert text as a sibling, before, or after the specified element.

					const element = document.getElementById('target');
					element.insertAdjacentText('beforebegin', 'This text is inserted before the target element');
				
				Arguments:
				
				(D) `positon`: positon can be one of the following:-
					
					I. `beforebegin`: Insert HTML immediately before element.
					II. `afterbegin`: Insert HTML into element at the beginning.
					III. `beforeend`: Insert HTML into element at the end.
					IV. `afterend`: Insert HTML immediately after element.

				(E) `content`: this should be relative to the name of the function like for `insertAdjacentHTML`, you should provide it The HTML code as a String for example:- 
					
					"<p>This is an HTML code as a String</p>"

			(XII) `insertBefore()`: This method inserts a node before a specified child node as a new child of a specified parent node.

				const parentElement = document.getElementById('parent');
				const newChild = document.createElement('p');
				const referenceNode = document.getElementById('reference');
				parentElement.insertBefore(newChild, referenceNode);

			(XIII) `insertAfter()`: This method inserts a node after a specified child node as a new child of a specified parent node.

				const parentElement = document.getElementById('parent');
				const newChild = document.createElement('p');
				const referenceNode = document.getElementById('reference');
				parentElement.insertAfter(newChild, referenceNode);

			(XIV) `createTextNode`(): This method creates a new text node with the specified text content and appends it to the specified parent node.

				const newText = document.createTextNode('This is a new text node');
				const parentElement = document.getElementById('parent');
				parentElement.appendChild(newText);
				
		(c) Modifying Element Attributes and Content:

			Attribute Functions & Properties:-

			(I) `getAttribute(name)`: Retrieves the value of an element's attribute.

				let srcValue = imageElement.getAttribute("src");

			(II) `setAttribute(name, value)`: Sets the value of an element's attribute.

				imageElement.setAttribute("alt", "A beautiful landscape");
			
			(III) `hasAttribute(name)`: checks if an element has a specific attribute. It's used with elements to determine whether the specified element has the attribute or not, and It returns a Boolean value.

				for Example :-

					HTML:

					<p id="myParagraph" title="Sample Title">Some text.</p>

					JavaScript:

						let paragraph = document.getElementById("myParagraph");
						// Check if the paragraph has the "title" attribute

						if (paragraph.hasAttribute("title")) {
						  console.log("The paragraph has a title attribute");
						} else {
						  console.log("The paragraph does not have a title attribute");
						}

			(IV) `removeAttribute(name)`: removes a specified attribute from an HTML element for Example:-

				HTML:

					<p id="myParagraph" title="Sample Title" class="highlight">Some text.</p>

				JavaScript:

					let paragraph = document.getElementById("myParagraph");
  
  					// Removing the 'title' attribute
  					paragraph.removeAttribute("title");

  					// Removing the 'class' attribute
  					paragraph.removeAttribute("class");

  					// Display the element's attributes after removal
  					console.log(paragraph.attributes);

			(V) `attributes`: property is used to access a collection of all the attributes of a specified element. It returns a NamedNodeMap, which is similar to an array but not exactly an array, containing all the attributes of the specified element. for Example:- 

				HTML:

					<p id="myParagraph" title="Sample Title" class="highlight">Some text.</p>

				JavaScript:

					let paragraph = document.getElementById("myParagraph");
  					// Accessing the attributes of the paragraph element
  					let attributeList = paragraph.attributes;

  					// Loop through the list of attributes
  					for (let i = 0; i < attributeList.length; i++) {
  					  	console.log(attributeList[i].name + " = " + attributeList[i].value);
  					}

			(VI) `data-*`: Attribute
			
				(A) `data-*`: attribute in HTML allows you to add your custom attribute but it should start with `data-` and then name of your attribute, and you can put any value you want, and you can also retrieve that value using `dataset` property in js and then the the name of your attribute which is after `data-`, and you can perform task with them in anyway you want to.

				for Example:-

					HTML:

						<div id="myElement" data-name="John" data-age="30"></div>

					JavaScript:

						const element = document.getElementById('myElement');
						console.log(element.dataset.name); // Prints: "John"
						console.log(element.dataset.age); // Prints: "30"

			(VII) Class Manipulation: `className` and `classList` are properties that are used to interact with the CSS classes of an HTML element. These properties allow you to manipulate the class attribute of an element
	
				(a) `className` property returns a string that represents the class attribute of the element.
				(b) `classList` property returns a collection of the class names of the element.

				Here's some of the common functions used with `classList` properties:

				(c) `add(className)`: Adds a class to the element. If the class already exists, it won't add another instance of the same class.
				(d) `remove(className)`: Removes a class from the element. If the class doesn't exist, this method has no effect.
				(e) `toggle(className)`: Toggles a class on the element. If the class exists, it will be removed; if it doesn't exist, it will be added.
				(f) `contains(className)`: Checks whether the element has a specific class. Returns true if the class exists, false otherwise.

				for Example:-

					HTML:

					    <p id="myParagraph" class="content">Some content here.</p>
					    <button onclick="changeStyle()">Change Style</button>

					CSS:

					    .highlight {
					        color: red;
					    }

					JavaScript:

					    const changeStyle = ()=>{

							// Getting The Element
					        let element = document.getElementById("myParagraph");

					       	element.className // returns the All of the classes as a String

							// Add a Class
					        element.classList.add("highlight");

							// remove a Class
					        element.classList.remove("content");
					        
							// check if an element has a class and it returns a Boolean
					        element.classList.contains("highlight");
							
							// Toggles The presence of a Class in the element
					        element.classList.toggle("highlight");
					    }

			Content Modifying Element Tags:-

			(VII) `textContent`: Gets and sets the text content of an element, excluding HTML tags.

				paragraphElement.textContent = "Updated text content";

			(VIII) `innerHTML` is a property of an HTML element, such as a <div> or a <p>. It represents the content of the element as a string, including both the HTML markup and the text content within the element. You can also set the innerHTML property to change the content of an element. This is a powerful way to dynamically update the content of a webpage.

				// Get the innerHTML of an element
				let element = document.getElementById("myElement");
				let content = element.innerHTML;

				// Set the innerHTML of an element
				element.innerHTML = "<p>New content</p>";

			(IX) `outerHTML` is similar to `innerHTML`, but it represents the entire HTML element, including its start tag, end tag, and all of its content. It returns the element and its contents as a string. You can use `outerHTML` to replace an entire element, including itself, with new HTML content.

				// Get the outerHTML of an element
				let element = document.getElementById("myElement");
				let elementHTML = element.outerHTML;

				// Replace an element with new HTML content
				element.outerHTML = "<div>New element</div>";

			(X) `Document.write()`: writes a string of text to a document stream, such as an HTML document. It's often used for testing and simple demonstrations, but it's not recommended for use in regular scripts, as it can overwrite the entire document if used after the document has finished loading. for example:-

				document.write("Hello, World!");
				
		(d) `addEventListener(event, callback)` Function

			(I) `addEventListener(event, callback)`: attaches to HTML elements to listen for specific events (such as user interactions or changes in the page) and respond to them when they occur

				Syntax:-

					element.addEventListener(eventType, callbackFunction);

			(II) `element`: The HTML element to which you want to attach the event listener.

			(III) eventType: The type of event you want to listen for, such as "click," "mouseover," "keydown," etc. Here's a full list of eventTypes:-

				Mouse Events:-

				(A) `click`: Occurs when a mouse click is detected.
				(B) `mousedown`: Fired when the mouse button is pressed.
				(C) `mouseup`: Fired when the mouse button is released.
				(D) `mousemove`: Occurs when the mouse pointer moves.
				(E) `mouseover`: Triggered when the mouse enters an element.
				(F) `mouseout`: Fired when the mouse leaves an element.
				(G) `mouseenter` and `mouseleave`: Similar to `mouseover` and `mouseout` but do not bubble.

				Keyboard Events:-

				(H) `keydown`: Occurs when a keyboard key is pressed.
				(I) `keyup`: Fired when a keyboard key is released.
				(J) `keypress`: Fired when a character key is pressed.
				
				Form Events:-

				(K) `submit`: Triggered when a form is submitted.
				(L) `reset`: Fired when a form is reset.
				(M) `input`: Occurs when the value of an input field changes.
				(N) `change`: Fired when the value of a form element changes (e.g., select, checkbox).

				Focus Events:-

				(O) `focus`: Occurs when an element receives focus.
				(P) `blur`: Fired when an element loses focus.
				
				Window Events:-

				(Q) `load`: Triggered when a web page finishes loading.
				(R) `unload`: Fired when a page is unloaded or refreshed.
				(S) `resize`: Occurs when the browser window is resized.
				(T) `scroll`: Fired when the user scrolls the page.

				Document Events:-

				(U) `DOMContentLoaded`: Occurs when the HTML document is completely loaded and parsed.
				(V) `readystatechange`: Fired when the ready state of the document changes.
				Touch Events (for mobile devices):-
				(W) `touchstart`: Fired when a touch point is placed on the touch surface.
				(X) `touchend`: Triggered when a touch point is removed from the touch surface.
				(Y) `touchmove`: Occurs when a touch point is moved along the touch surface.
				(Z) `touchcancel`: Fired when a touch event is canceled.

				Drag and Drop Events:-

				(ZA) `dragstart`: Occurs when an element starts to be dragged.
				(ZB) `dragend`: Fired when the element is no longer being dragged.
				(ZC) `dragenter`, `dragover`, `dragleave`: Events related to dragging elements over a target.
				(ZD) `drop`: Occurs when a dragged element is dropped on a target.

				Media Events (for audio and video):-

				(ZE) `play`, `pause`, `ended`: Events related to media playback.

				Custom Events:-

				(ZF) You can create custom events using the `CustomEvent` constructor and dispatch them on DOM elements.

			(IV) `callbackFunction`: A function that will be called when the specified event occurs.

			Example:-

				const button = document.getElementById("myButton");

				button.addEventListener("click", ()=>{

					alert("Button clicked!");

				});

			Key Concepts and Usage:

			(V) Event Types: Events can be various interactions or occurrences, such as clicks, keypresses, mouse movements, form submissions, and more. Different HTML elements support different types of events.
			(VI) Callback Function: The callback function is executed when the specified event occurs. It can contain the code that responds to the event. It typically takes an event object as its parameter, allowing you to access information about the event, like the target element or mouse coordinates.
			(VII) `Event Flow`: Events propagate through the DOM tree in two phases: capturing and bubbling. You can control the phase in which the event listener operates by passing an optional third argument, `useCapture`, to `addEventListener`.

				(A) `useCapture` set to true (default): Event listener operates during the capturing phase, starting from the outermost ancestor and moving inward to the target element.

				(B) `useCapture` set to false or omitted: Event listener operates during the bubbling phase, starting from the target element and moving outward to the outermost ancestor.

					element.addEventListener("click", callbackFunction, useCapture);

			(VIII) Event Removal: To remove an event listener, you should use the `removeEventListener` method. This is important to avoid memory leaks when an element is removed from the DOM or when you no longer need the listener.

				element.addEventListener("click", ()=>{
					console.log("click detected)
				});

				// Remove the Event Listener
				element.removeEventListener("click", ()=>{
					console.log("click detected)
				});

				(Note: You have to provide it both `event` and `handler`, keep in mind that yhe reference of `event` and `handler` have to be EXACT as `addEventListener`(s) reference or else it won't work)

			(IX) Event Object: The event object provides information about the event, such as the target element, event type, and additional data specific to the event type.

				element.addEventListener("click", function(event) {

				  console.log(event.type); // "click"

				  console.log(event.target); // The clicked element

				});

		(e) Form Handling:

			(I) `submit()`: Submits a form.

				formElement.submit();

		(f) Nodes

			(I) 'nodes' typically refer to elements in the Document Object Model (DOM). The DOM represents the structure of an HTML or XML document as a tree-like structure of objects, where each object corresponds to a part of the document. Nodes are the individual elements or parts within this tree structure, and they can represent HTML elements, text, attributes, or other parts of the document

			Here are some common types of nodes in the DOM:

			(II) 'Element Nodes' : These nodes represent HTML elements and are the most common type of nodes in the DOM. For example, <div>, <p>, <a>, and <img> elements are represented as element nodes.
			(III) 'Text Nodes' : Text nodes represent the text content within an element. For example, the text between <p>...</p> tags is represented as a text node.
			(IV) 'Attribute Nodes' : These nodes represent the attributes of an element. For example, if you have an <a> element with an href attribute, the href attribute itself is represented as an attribute node.
			(V) 'Comment Nodes' : Comment nodes represent comments within the HTML code. For example, <!-- This is a comment --> is represented as a comment node.
			(VI) 'Document Nodes' : The top-level node in the DOM tree is the document node, representing the entire HTML or XML document. It serves as the root of the DOM hierarchy.

			(VII) Nodes are organized hierarchically, forming a tree structure. Elements contain other elements, text nodes, and potentially other types of nodes as children. This hierarchy reflects the nesting of elements in the HTML document.

			Here's a simple example of how to access and manipulate nodes in JavaScript:-

				// Accessing an element node by its ID
				const elementNode = document.getElementById("myElement");

				// Accessing a text node
				const textNode = elementNode.firstChild; // Assuming the text node is the first child

				// Modifying an element's text content
				elementNode.textContent = "New content";

				// Accessing and modifying an attribute
				const linkElement = document.getElementById("myLink");
				const hrefAttribute = linkElement.getAttribute("href");
				linkElement.setAttribute("href", "https://www.example.com");

				// Creating a new element node
				const newElement = document.createElement("div");
				newElement.textContent = "New element content";
				document.body.appendChild(newElement);

			Here's Some Properties and Built-in Functions of Nodes:-

			(VIII) `nodeName` Property:

				(A) The nodeName property is used to retrieve the name of the node of an element within the DOM. It returns the name of the HTML tag in uppercase or the node name in the case of non-HTML elements.
				(B) It is particularly useful when you need to identify the type of the node, such as whether it's a `<div>`, `<p>`, `<span>`, or any other type of node.

				Example :-

					HTML:

						<div id="myDiv"></div>

					JavaScript:

						const element = document.getElementById('myDiv');
						console.log(element.nodeName); // "DIV"

			(IX) `nodeValue` property
				
				(A) It represents the value of the current node, depending on its type. This property is accessible for different types of nodes such as Element, Text, Comment, etc.

				(B) For Element nodes: The nodeValue property returns `null`. If you want to access the text content of an element node, you can use the textContent property instead.

				(C) For Text nodes: The nodeValue property returns the text content of the text node.

				(D) For Comment nodes: The nodeValue property returns the content of the comment node.
				
				for Example:-

					<!DOCTYPE html>
					<html>
					<body>

					<p id="demo">Some text.</p>

					<script>
					  let txt = document.getElementById("demo").firstChild;
					  console.log(txt.nodeValue); // Output: "Some text."

					  let comment = document.createComment("I am a comment");
					  console.log(comment.nodeValue); // Output: "I am a comment"
					</script>

					</body>
					</html>
					
			(X) `data` Property (NOT THE ATTRIBUTE ONE):-
				
				(a) `data` property is specific to text nodes in the DOM. It represents the text content of a text node, which is similar to the `nodeValue` property but it's used for text nodes specifically. The `data` property provides the same functionality as `nodeValue` but is used primarily for text nodes.

				Here's an example of how to use the data property:-

					HTML:

						<p id="demo">Some text.</p>

					JavaScript:

					  	let txt = document.getElementById("demo").firstChild;
					  	console.log(txt.data); // Output: "Some text."

			(XI) `remove()` removes the selected element

				Here is an example of how to use the remove() method:

				const elementToRemove = document.getElementById('elementToRemove');
				elementToRemove.remove();

		(g) `Style` Object

			(I)`style`: allows you to access and manipulate the inline CSS styles of an element directly through JavaScript
			(II) You can access the style object of an HTML element using JavaScript. For example:

				const element = document.getElementById("myElement");
				const styles = element.style;

			(III) You can change the CSS properties of an element using the style object. Each CSS property corresponds to a property of the style object, and you can set or retrieve their values as follows:

				// Get the value of a CSS property
				const backgroundColor = element.style.backgroundColor;

				// Set the value of a CSS property
				element.style.color = "blue";
				element.style.fontSize = "16px";
				element.style.backgroundColor = "lightgray";

			(IV) Property Names: When accessing CSS properties using the style object, use camelCase versions of the CSS property names. For example, use `backgroundColor` instead of `background-color`.
			(V) Values: Property values should be assigned as strings, just like in CSS. Numeric values that represent lengths or numbers can be assigned as strings with units (e.g., "16px" or "2rem").
			(VI) Inline Styles: The style object only deals with inline styles defined in the style attribute of the element. It won't access or modify styles defined in external stylesheets or through the `class` attribute.

		(h) Document.element

			(a) You can also directly write these specific tags list down here to get those elements 
			(note: It's limited to these listed down here only if you want to use tags other then these, than use functions like `getElementsByClassName()[]` )

			(b) Document.body: Represents the <body> element of the HTML document and allows you to access and manipulate its content.
			(c) Document.head: Represents the <head> element of the HTML document, which contains metadata and links to external resources.
			(d) Document.documentElement: Represents the root element of the HTML document, typically the <html> element, allowing access to the entire document structure. 
			(e) Document.title: Allows you to access and modify the title of the HTML document, which appears in the browser's title bar or tab.
		
	(vi) Finding Functions

		(a) `matches()`, `closest()`, and `contains()` are three JavaScript functions used in the context of working with the Document Object Model (DOM) to interact with HTML elements

		Explaination individually :-

		(b) `matches()`: It's used to check whether an element matches a specific CSS selector. It returns `true` if the element matches the selector; otherwise, it returns `false`.This function is often used in event handling and selecting elements based on specific criteria. for example:-

			// Check if an element with ID "myElement" is a <div>
			const element = document.getElementById("myElement");
			const isDiv = element.matches("div");

			// Check if an element with class "active" is a <button>
			const button = document.querySelector(".active");
			const isButton = button.matches("button");

		(c) `closest()` Function: The `closest()` function is used to find the closest ancestor (parent or higher-level ancestor) of an element that matches a specified CSS selector.It is helpful for traversing the DOM tree upwards from a given element to find a specific ancestor.for example:-

			// Find the closest <div> ancestor of a <button> element
			const button = document.querySelector("button");
			const closestDiv = button.closest("div");
			
			// Find the closest element with class "container" of an element with class "item"
			const item = document.querySelector(".item");
			const closestContainer = item.closest(".container");

			(Note: It returns The ancestor or parent of the Element not a Booleon)
		
		(d) `contains()` Function: The `contains()` function is used to check if one DOM element is a descendant of another element. It returns 'true' if the specified element is a descendant; otherwise, it returns 'false'. It is useful for checking if one element contains another, such as checking if a parent element contains a child element. Example: 	

			// Check if an element with ID "parent" contains an element with ID "child"
			const parent = document.getElementById("parent");
			const child = document.getElementById("child");
			const isChildContained = parent.contains(child);
			
			// Check if the document body contains an element with class "my-element"
			const isElementContained = document.body.contains(document.querySelector(".my-element"));
			
	XML and HTML Compatibility: The DOM can be used with both XML and HTML documents, making it versatile for various web development tasks.The DOM plays a crucial role in modern web development, enabling developers to create interactive and dynamic web applications. It bridges the gap between the structure of web documents and the programming languages used to build web applications, allowing for rich user experiences and real-time updates.

14. BOM

	(i) The Browser Object Model (BOM) is a part of the JavaScript programming language that represents and controls the web browser itself. Unlike the Document Object Model (DOM), which deals with the structure and content of web documents (HTML, XML), the BOM focuses on controlling and interacting with the browser's features and behavior. It provides a set of objects and methods to manage browser-specific functionality and properties. Here are some key aspects and functions of the BOM:
	
	(ii) `Prompt/Alert/Confirm` Functions

		(a) `prompt(message, defaultValue)` :"It's used to display a dialog box that prompts the user to enter some input. It takes two arguments:-

			(I) message: The message to display to the user, typically instructing them on what to enter.
			(II) DefaultValue (optional): The default value pre-filled in the input field.

			for example:

				let userInput = prompt("Please enter your name:", "John Doe");

				(A) In this example, a dialog box will appear with the message "Please enter your name:" and an input field pre-filled with "John Doe." The user can enter their name, and the input will be stored in the userInput variable.

			(III) `prompt()` returns the text entered by the user as a string or null if the user clicks "Cancel" or closes the dialog.

		(b) `alert(message)` :"alert() is used to display a simple message to the user in a dialog box. It typically contains an "OK" button to close the dialog." for example:-

			alert("Hello, World!");

			(IV) The above code will display a dialog box with the message "Hello, World!" and an "OK" button. It's commonly used for displaying informative messages to users.

		(c) `confirm(message)` :" : Displays a message in a confirm dialog with "OK" and "Cancel" buttons." for example:-

			let result = confirm("Are you sure?");


			// Display an alert message
			window.alert("This is an alert!");

			// Show a confirmation dialog
			const result = window.confirm("Are you sure?");

	(ii) Navigation Control:

		(a) `Location` Object

			The `location` object in JavaScript represents the current URL of the web page displayed in the browser. It provides access to various properties and methods that allow you to interact with and manipulate the URL. The `location` object is a property of the global window object, making it easily accessible in your scripts. Here are some of the key properties and methods of the `location` object:

			(I) `href`: This property contains the complete URL of the current web page, including the protocol (e.g., "http" or "https"), domain, port, path, and query parameters.

				let currentURL = location.href;

			(II) `host`: The `host` property contains the domain and port number of the current URL.

				let domainAndPort = location.host;

			(III) `hostname`: The `hostname` property holds the domain name of the current URL, excluding the port number.

				let domainName = location.hostname;

			(IV) `protocol`: This property represents the `protocol` or scheme of the current URL (e.g., "http:" or "https:").

				let currentProtocol = location.protocol;

			(V) `port`: The `port` property contains the port number specified in the URL. It defaults to 80 for HTTP and 443 for HTTPS.

				let currentPort = location.port;

			(VI) `pathname`: The `pathname` property represents the path part of the URL, including any directories or filenames.

				let currentPath = location.pathname;

			(VII) `search`: The `search` property contains the query string portion of the URL, including the leading "?" character.

				let queryString = location.search;

			(VIII) `hash`: The `hash` property contains the fragment identifier part of the URL, including the leading "#" character. It is often used to navigate within the same page.

				let fragmentIdentifier = location.hash;

			(IX) assign(url): The assign() method loads a new URL and replaces the current page's URL in the browser's history.

				location.assign("https://www.example.com");

			(X) `replace(url)`: The `replace()` method loads a new URL and replaces the current page's URL in the browser's history without creating a new entry in the history.

				location.replace("https://www.example.com");

			(XI) `reload()`: `The reload()` method reloads the current page.

				location.reload();

		(b) `history` Object

			(I) `history` object includes various properties and methods that allow you to navigate the browser's history and manipulate the browsing session.
			
			Some of the key properties and methods of the history object include:

			(II) `back()`: This method loads the previous URL in the history list, which is the equivalent of clicking the browser's back button.
			(III) `forward()`: This method loads the next URL in the history list, which is the equivalent of clicking the browser's forward button.
			(IV) `go()`: This method loads a specific URL from the history list, with navigation relative to the current page.
			(V) length: This property returns the number of URLs in the history list.
			(VI) `pushState()`: This method adds a new state to the browser history, allowing you to modify the URL of the current document without reloading the page.
			(VII) `replaceState()`: This method modifies the current history entry, replacing it with the new state, but without creating a new entry in the history stack.
			
			Here's an example of using the history object to navigate through the browser's history:

				// Go back one page in the history
				history.back();

				// Go forward one page in the history
				history.forward();

				// Go back or forward in history by a specific number of pages
				history.go(-2); // Goes back two pages in the history
				history.go(3); // Goes forward three pages in the history

				// Accessing the length of the history list
				console.log(history.length);

				// Adding a new state to the history
				history.pushState({ page: 2 }, "Page 2", "page2.html");

				// Modifying the current history entry
				history.replaceState({ page: 3 }, "Page 3", "page3.html");

	(iii) Timeout Functions

		(a) `setTimeout()`: This function executes a specified function or a specified piece of code 'ONCE' after a specified delay. It takes two main arguments: a function or a piece of code to execute and the delay time in milliseconds before the execution. Optionally, it can take additional arguments that will be passed to the function. for Example:-

			let timeoutID = setTimeout(() => {
			    console.log('Delayed log after 2 seconds');
			}, 2000);
			console.log(timeoutID) // Returns The ID of The Timeout which is essential to Terminate Timeouts later on

			Addition Arguments Example:-

			const sum = (a, b, c)=>{
            	console.log(a+b+c)
        	};
        	const timeoutID1 = setTimeout(sum, 5000, 5, 3, 2); //argument after the second argument will be passed to the function
			// outputs: 10

		(b) `setInterval()`: This function 'REPEATEDLY' executes a specified function or a specified piece of code at a specified time interval. It also takes two main arguments: a function or a piece of code to execute and the time interval in milliseconds between each execution. Like `setTimeout()`, it can also take additional arguments.

			let count = 0;

			let intervalTimeoutID = setInterval(() => {

			    count++;
			    console.log('Interval log:', count);

			    if (count >= 5) {
			        clearInterval(intervalTimeoutID); // Stop the interval after 5 executions
			    }

			}, 1000);

			console.log(intervalTimeoutID)

		(c) You can Terminate any scheduled timeout by using `clearTimeout()` and `clearInterval()`, respectively and They requires ID of the Timeout which is stored inside the variable which is running the Timeout.

		(Note: The variable which is running The Timeout Function contains The ID of The Timeout)

	(vii) `screen` Object

		// Get screen width and height
		const screenWidth = window.screen.width;
		const screenHeight = window.screen.height;

	(viii) `navigator` Object

		// Get browser name and version
		const browserName = navigator.appName;
		const browserVersion = navigator.appVersion;

	(ix) Popup Windows:

		// Open a new popup window
		const newWindow = window.open("https://www.example.com", "Popup", "width=400,height=300");

	(xiv) The BOM is a powerful part of JavaScript that allows web developers to interact with and control the browser's behavior, manage user interface elements, and implement various client-side features. It plays a vital role in creating dynamic and interactive web applications.
	
15. Auto-Correction by Browser

	(i) Auto-correction by browsers in HTML typically refers to the automatic correction of certain HTML and markup errors made by web developers to ensure that web pages render correctly and consistently for users. Browsers perform this auto-correction when parsing and rendering HTML documents. 
	
	Here are some common examples of auto-correction done by browsers:

	(ii) Unclosed Tags: Browsers often attempt to close unclosed HTML tags to maintain the document's structure. For example, if you forget to close a `<p>` element, the browser may automatically close it for you.

		<!-- Original Code -->
		<div>
		  <p>This is a paragraph.
		</div>
		
		<!-- Auto-Corrected by Browser -->
		<div>
		  <p>This is a paragraph.</p>
		</div>
		
	(iii) Mismatched Tags: Browsers may also attempt to correct mismatched or improperly nested HTML tags to create a valid HTML structure. For instance, if you open a `<strong>` tag within a paragraph but forget to close it, the browser might close it at the end of the paragraph.

		<!-- Original Code -->
		<p>This is a <strong>bold text.</p>

		<!-- Auto-Corrected by Browser -->
		<p>This is a <strong>bold text.</strong></p>

	(iv) Attribute Quoting: Browsers may add missing attribute quotes, such as double quotes around attribute values, to ensure valid HTML.

		<!-- Original Code -->
		
		<a href=https://www.example.com>Visit Site</a>

		<!-- Auto-Corrected by Browser -->

		<a href="https://www.example.com">Visit Site</a>

	(v) Self-Closing Tags: Browsers often allow self-closing tags (e.g., <img>, <br>, <input>) to be used without the trailing slash /. While not strictly required in HTML5, the browser may add it for consistency.

		<!-- Original Code -->

		<img src="image.jpg">

		<!-- Auto-Corrected by Browser -->
		
		<img src="image.jpg" />

	(vi) Lowercase Tags: HTML is case-insensitive, but browsers tend to convert tag names to lowercase for consistency.

		<!-- Original Code -->

		<A HREF="https://www.example.com">Visit Site</A>

		<!-- Auto-Corrected by Browser -->

		<a href="https://www.example.com">Visit Site</a>

16. Event Attributes in HTML:

	(i) In HTML, There's some Attributes That Allows You to Run Specific Code when specific event Takes place, However It can also be Done by `addEventListener()` function, and you can also use Events from `addEventListener()` function just add 'on' prefix to them to use them as attributes in HTML, or remove 'on' prefix to use them in `addEventListener()` functions

	(Note: If you're gonna write more than 1 line of code in these attributes then, It's recommended to use functions to execute code using These Attributes.)

	(ii) Here's a list of Event Attributes:
		
		Mouse Events: 

		(a) `onclick`: Fires when the left mouse button is clicked.
		(b) `ondblclick`: Fires when the left mouse button is double-clicked.
		(c) `onmousedown`: Fires when any mouse button is pressed down.
		(d) `onmouseup`: Fires when any mouse button is released.
		(e) `onmouseover`: Fires when the mouse pointer moves over an element.
		(f) `onmousemove`: Fires when the mouse pointer is moved.
		(g) `onmouseout`: Fires when the mouse pointer moves out of an element.
		(h) `onmouseenter`: Fires when the mouse pointer enters an element.
		(i) `onmouseleave`: Fires when the mouse pointer exits an element.
		(j) `oncontextmenu`: Fires when the right mouse button is clicked, opening the context menu.

		Keyboard Events: 

		(k) `onkeydown`: Fires when any key is pressed down.
		(l) `onkeypress`: Fires when a key is pressed down and released.
		(m) `onkeyup`: Fires when a key is released.

		Form Events: 

		(n) `onsubmit`: Fires when a form is submitted.
		(o) `onreset`: Fires when a form is reset.
		(p) `onchange`: Fires when the value of an input element is changed.
		(q) `oninput`: Fires when the content of an input element is changed.
		(r) `onfocus`: Fires when an input element receives focus.
		(s) `onblur`: Fires when an input element loses focus.

		Window Events: 

		(t) `onload`: Fires when the page has finished loading.
		(u) `onunload`: Fires when the page is about to be unloaded.
		(v) `onresize`: Fires when the browser window is resized.
		(w) `onscroll`: Fires when the content of a window or element is scrolled.

		Touch Events (For Mobile and Tablets): 

		(x) `ontouchstart`: Fires when a touch point is placed on the touch surface.
		(y) `ontouchend`: Fires when a touch point is removed from the touch surface.
		(z) `ontouchmove`: Fires when a touch point is dragged across the touch surface.
		(za) `ontouchcancel`: Fires when a touch point is disrupted, such as by an alert popping up.

		Media Events: 

		(zb) `onabort`: Fires when the loading of media is aborted.
		(zc) `oncanplay`: Fires when the media can be played.
		(zd) `oncanplaythrough`: Fires when the media can be played through to the end without buffering.
		(ze) `ondurationchange`: Fires when the duration of the media changes.
		(zf) `onemptied`: Fires when the media is emptied.
		(zg) `onended`: Fires when the media has reached the end.
		(zh) `onerror`: Fires when an error occurs while loading or playing the media.
		(zi) `onloadeddata`: Fires when the first frame of the media has finished loading.
		(zj) `onloadedmetadata`: Fires when the metadata of the media has finished loading.
		(zk) `onloadstart`: Fires when the browser starts to load the media.
		(zl) `onpause`: Fires when the media is paused.
		(zm) `onplay`: Fires when the media starts playing.
		(zn) `onplaying`: Fires when the media is playing.
		(zo) `onprogress`: Fires periodically as the media is loading.
		(zp) `onratechange`: Fires when the playback rate of the media changes.
		(zq) `onseeked`: Fires when the seeking operation has finished.
		(zr) `onseeking`: Fires when the seeking operation starts.
		(zs) `onstalled`: Fires when the media is unable to play due to an error.
		(zt) `onsuspend`: Fires when the loading of the media is suspended.
		(zu) `ontimeupdate`: Fires when the current playback position of the media changes.
		(zv) `onvolumechange`: Fires when the volume of the media changes.
		(zw) `onwaiting`: Fires when the media is waiting for more data to load.

		Drag Events: 

		(zx) `ondrag`: Fires when an element is being dragged.
		(zy) `ondragend`: Fires when a drag operation is completed.
		(zz) `ondragenter`: Fires when an element is dragged over a target element.
		(zza) `ondragleave`: Fires when an element is dragged out of a target element.
		(zzb) `ondragover`: Fires when an element is being dragged over a target element.
		(zzc) `ondragstart`: Fires when a drag operation starts.
		(zzd) `ondrop`: Fires when a dragged element is dropped onto a target element.

		Clipboard Events: 

		(zze) `oncopy`: Fires when content is copied to the clipboard.
		(zzf) `oncut`: Fires when content is cut to the clipboard.
		(zzg) `onpaste`: Fires when content is pasted from the clipboard.
		
	(iii) if you've selected an Element which and You want to add evenType to it then you can these the events directly as properties in JavaScript.

	(iv) Examples:

		// using The Attributes in HTML

		<button onclick="()=>{console.log('Click Detected')}" id="EventElement">Click me</Button>

		// using `addEventListener` function

		let element = document.getElementById("EventElement")
		element.addEventListener("click",()=>{
			console.log("Click Detected")
		})

		// using The Attributes in JavaScript

		let element = document.getElementById("EventElement");
		element.onclick = ()=>{
			console.log("Clicked Detected");
		};

	(v) `Event` Object


		(a) when an event is triggered, an event object is automatically created and passed as an argument to the event handler function. This event object contains information and properties related to the event that was triggered. 
		
		Some common properties that can be accessed from the event object include:

		(b) `target`: This property refers to the element that triggered the event.
		(c) `type`: This property specifies the type of event that was triggered.
		(d) `currentTarget`: This property refers to the element that the event handler is attached to.
		(e) `eventPhase`: This property indicates the phase of the event flow (capturing, at target, or bubbling).
		(f) `stopPropagation()`: This method stops the propagation of the event through the DOM.
		(g) `preventDefault()`: This method prevents the default action of the event from occurring.
		(h) `stopImmediatePropagation()`: This method prevents other listeners of the same event from being called.
		(i) `clientX` and `clientY` provides the coordinates of the mouse pointer relative to the browser's viewport when an event is triggered. These properties are particularly useful for tracking the position of the mouse during mouse-related events such as `mousemove`, `mousedown`, `mouseup`, and `click`.

			(a) `clientX`: This property provides the horizontal coordinate of the mouse pointer relative to the viewport, excluding any scroll offset.
			(b) `clientY`: This property provides the vertical coordinate of the mouse pointer relative to the viewport, excluding any scroll offset.

			for Example:-
			
				HTML:

					<div onmousemove="showCoordinates(event)" style="height:200px; width:400px; border:1px solid black;"> Move the mouse inside this box </div>

				JavaScript:

					const showCoordinates = (event)=>{
						let x = event.clientX;
						let y = event.clientY;
					  	console.log("X: " + x + " Y: " + y);
					}

		Here is an example of how you can access some of the properties from the event object:


			HTML:

				<button onclick="myFunction(event)">Click me</button>

			JavaScript:

				const myFunction = (event)=>{
				  console.log("Event type: " + event.type);
				  console.log("Target element: ", event.target);
				  console.log("Current element: ", event.currentTarget);
				}

			(Note: The `event` object can have name of your choice, you can name it whatever you want)
			
			In this example, the myFunction function is triggered by the click event on the button. It logs the type of event, the target element that triggered the event, and the current element where the event handler is attached.

Section: Key Concepts

17. `Synchronous` and `Asynchronous`

	(i) synchronous and asynchronous actions refer to different ways in which tasks are executed in a program.
	
	(ii) Synchronous Actions: Synchronous actions are those that occur one after the other, in a sequence. When a function is called synchronously, the program waits for it to finish before moving on to the next operation. It means the program follows a strict order of execution and one operation is completed before the next one starts. This can sometimes lead to blocking behavior where a slow operation can halt the entire program until it completes.for Example:-

		console.log("First");
		console.log("Second");
		console.log("Third");
		
		In this example, the program will print "First", "Second," and "Third" in that order.

	(iii) Asynchronous Actions: Asynchronous actions, on the other hand, allow the program to continue executing other operations while waiting for a particular task to complete. In this case, the program doesn't wait for the task to finish, but it provides a callback function to be executed once the task is completed. Asynchronous actions are often used for time-consuming operations, such as making network requests or reading/writing files, to prevent blocking the execution of other parts of the program. for Example:-

		console.log("First");
		setTimeout(() => {
		    console.log("Second");
		}, 2000);
		console.log("Third");

		In this example, "First" and "Third" are printed immediately, while "Second" is printed after a 2-second delay due to the setTimeout function.

		(a) Callbacks are called "Callback - based" style of async programming. A function that does something asynchronously should provide a callback argument where we put the function to run after it's complete.

18. Advance Functions

	(i) Callback Functions:

		(WARNING: Callback Functions can Lead to Pyramid of Doom AKA Callback Hell!)

		(a) `Callback function` are functions which is passed as an argument to another function and is executed after some operation has been completed. Callback functions are a fundamental part of JavaScript's asynchronous nature and are widely used in scenarios where operations need to be performed in a non-blocking manner.
		
		Here's a simple example to illustrate the concept:

			const processData = (data, successCallback, failureCallback)=>{
			  	// Simulating an asynchronous operation
			  	setTimeout(() => {
			    	if (data) {
			      		successCallback('Data processed successfully');
			    	} else {
			      		failureCallback('Error: No data to process');
			    	}
			  	}, 2000);
			}

			const successCallback = (message)=>{
			  console.log(`Success: ${message}`);
			}

			const failureCallback = (message)=>{
			  console.log(`Failure: ${message}`);
			}

			// Using the processData function with the callback functions
			processData(true, successCallback, failureCallback);
			processData(false, successCallback, failureCallback);

			In this example, the `processData()` function simulates an asynchronous operation. It takes in some data, and depending on the data's availability, it either calls the `successCallback` with a success message or the `failureCallback` with an error message.

		(b) Callbacks are called "Callback - based" style of async programming. A function that does something asynchronously should provide a callback argument where we put the function to run after it's complete.
	
	(ii) `Error()` function. 

		(a) It's used for creating an error object. This error object can then be thrown using the `throw` keyword. It is commonly used for custom error handling within JavaScript programs. When an error occurs during the execution of a script, it's helpful to have a detailed error message that can help identify the issue. The `Error()` function allows developers to create their own error messages to provide more context and information about the error.
		
		Here's an example of how the `Error()` function can be used:

		// Creating a custom error
		const customError = new Error('This is a custom error message.');

		// Throwing the error
		throw customError;

		In this example, the `Error()` function creates an error object customError with the message "This is a custom error message." Later, the error is thrown using the throw keyword. When this error is thrown, the JavaScript interpreter will stop the execution of the program and show the error message along with the stack trace, which can be helpful for debugging and identifying the cause of the error.
	
	(iii) `JSON` Object

		(a) `JSON.parse()`: This function is used to parse a JSON string, converting it into a JavaScript object.

			const jsonStr = '{"name": "John", "age": 30, "city": "New York"}';
			const obj = JSON.parse(jsonStr);
			console.log(obj.name); // Output: John

		(b) `JSON.stringify()`: This function is used to convert a JavaScript object into a JSON string.

			const obj = { name: 'John', age: 30, city: 'New York' };
			const jsonStr = JSON.stringify(obj);
			console.log(jsonStr); // Output: {"name":"John","age":30,"city":"New York"}

		(c) `JSON.stringify()` with Replacer Function: The `stringify` function can take a replacer function as a second argument, allowing you to customize the serialization of specific properties.

			const obj = { name: 'John', age: 30, city: 'New York' };
			const jsonStr = JSON.stringify(obj, (key, value) => (key === 'city' ? undefined : value));
			console.log(jsonStr); // Output: {"name":"John","age":30}

		(d) `JSON.stringify()` with Replacer Array: You can also use an array as a replacer, specifying the properties you want to include in the serialized JSON string.

			const obj = { name: 'John', age: 30, city: 'New York' };
			const jsonStr = JSON.stringify(obj, ['name', 'age']);
			console.log(jsonStr); // Output: {"name":"John","age":30}
			
		(e) `JSON.stringify()` with Space Argument: The `stringify` function can also take a third argument, indicating the number of spaces to use for indentation.

			const obj = { name: 'John', age: 30, city: 'New York' };
			const jsonStr = JSON.stringify(obj, null, 2);
			console.log(jsonStr);
			/* Output:
			{
			  "name": "John",
			  "age": 30,
			  "city": "New York"
			} 
			*/

		(f) `<value>.toJSON` converts any Value to a JavaScript Object

	(iv) The `encodeURIComponent` and `decodeURIComponent` functions are used to manage special characters in URLs. Here's a breakdown of each:

		(a) `encodeURIComponent`: The `encodeURIComponent` function is used to encode special characters in a URL. It takes a single parameter, typically a string, and replaces any special characters with their encoded counterparts. This is particularly useful when you want to append parameters to a URL. It encodes all characters except the following: A-Z a-z 0-9 - _ . ! ~ * ' ( ).

			const uri = 'https://example.com/my page.html';
			const encodedURI = encodeURIComponent(uri);
			console.log(encodedURI);
			// output: "https%3A%2F%2Fexample.com%2Fmy%20page.html"

		(b) `decodeURIComponent`: The `decodeURIComponent` function performs the reverse operation of `encodeURIComponent`. It takes an encoded URI component as a parameter and decodes it, converting special characters back to their original form.

			const encoded = 'https%3A%2F%2Fexample.com%2Fmy%20page.html';
			const decoded = decodeURIComponent(encoded);
			console.log(decoded);
			// output: "https://example.com/my page.html"
			
19. Pyramid of Doom!

	(i) Pyramid of Doom, also known as Callback Hell, is a term used to describe the situation where multiple layers of nested callbacks make the code difficult to read and maintain. It is a common issue in asynchronous programming, especially when handling multiple asynchronous operations one after the other. In JavaScript, this often occurs when dealing with multiple nested callbacks, typically in scenarios such as nested asynchronous functions, event handling, or handling multiple AJAX requests.

	An Example of the Pyramid of Doom:

		operation01(function(result01) {
		    operation02(function(result02) {
		        operation03(function(result03) {
		            operation04(function(result04) {
		                operation05(function(result05) {
							aoeration06(function(result06) {
								operation07(function(result07) {
									operation08(function(result08) {
										operation09(function(result09) {
											operation10(function(result10) {
												operation11(function(result11) {
													operation12(function(result12) {
														operation13(function(result13) {
															operation14(function(result14) {
																operation15(function(result15) {
																	// and it keeps going
		            											});
		            										});
		            									});
		            								});
		            							});
		            						});
		            					});
		            				});
		            			});
		            		});
		            	});
		            });
		        });
		    });
		});
	
	(ii) The code structure becomes deeply nested and challenging to read as more operations are added. 
	It leads to the following issues:

	(iii) Readability: With deeply nested callbacks, the code becomes difficult to read and understand. This can make it challenging for other developers (and even the original developer) to maintain and extend the code.

	(iv) Debugging and Error Handling: Managing errors and debugging become complex, as it's not straightforward to determine which part of the code might be causing an issue.

	(v) To avoid the Pyramid of Doom, developers often use various techniques like modularization, promises, and async/await, which allow for more structured and readable code. Promises and async/await enable a more linear flow of the code, making it easier to handle asynchronous operations without deeply nested structures. These techniques provide a more elegant and maintainable way to handle asynchronous code, making it easier to manage errors and handle complex asynchronous operations.

20. Keywords

	(i) `new`

		(a) `new` keyword is used to create an instance of a user-defined object type or of one of the built-in object types that has a constructor function. When used with a constructor function, new creates a new object and sets the prototype of the newly created object to the constructor function's prototype

		Here is an example of using the new keyword:

			// Constructor function
			function Person(name, age) {
			    this.name = name;
			    this.age = age;
			}

			// Creating an instance of Person using the new keyword
			const john = new Person('John', 30);

			console.log(john.name); // Output: John
			console.log(john.age); // Output: 30

		When the new keyword is used with a constructor function, it performs the following steps:

		(b) It creates a new empty object.
		(c) It sets the value of `this` keyword to the newly created object inside the constructor function.
		(d) It adds properties to the newly created object using the `this` keyword.
		(e) If the constructor function does not explicitly return an object, it implicitly returns `this`, i.e., the newly created object.
		
		Using the `new` keyword allows you to create multiple instances of an object type with their own separate properties and methods

	(ii) `this`
		
		(a) `this` keyword refers to the object that is executing the current code. The specific value of `this` depends on the context in which it is used. Its value is determined by how a function is called and where it is called. The behavior of this can be a little tricky, but understanding the various rules can help in utilizing it effectively.

		Here's a basic understanding:

		(b) Global context: When used in the global context, `this` refers to the global object, which is the `window` object in the case of browsers.

			console.log(this === window); // true

		(c) Function context: In the context of a function, the value of `this` depends on how the function is called. In regular function calls, `this` refers to the global object. In object methods, `this` refers to the object that the method is a property of.

			const myObj = {
			  	property: 'value',
			  	myMethod: function() {
			    	console.log(this.property);
			  	}
			};

			myObj.myMethod(); // 'value'

		(d) Arrow functions: Arrow functions do not have their own `this` value. They inherit `this` from the enclosing scope.

			const myObj = {
			  	myMethod: function() {
			    	const myArrowFunc = () => {
			      		console.log(this);
			    	};
			    	myArrowFunc();
			  	},
				myArrowFunc: ()=>{
					console.log(this)
				}
			};


			myObj.myMethod(); // 'myObj' object

			myObj.myArrowFunc() // `window` object if browser, `global` object if Node.js

		(e) Constructor functions: In constructor functions, `this` refers to the specific instance of the object that is created and returned by the constructor function when using the `new` keyword.

			function Person(name) {
			  this.name = name;
			}

			const john = new Person('John');
			console.log(john.name); // 'John'
		
		(h) Event Handlers:

			(I) `this` keyword is used within the context of event handlers, such as in DOM event listeners, the `this` keyword typically refers to the element that triggered the event.

			Here's how the `this` keyword works in event handlers:

			(II) `Inline Event Handlers`:
			   	
				(A) In HTML, you can define event handlers inline using attributes like `onclick`, `onmouseover`, etc. In this case, when the event handler is invoked, the `this` keyword refers to the DOM element to which the event handler is attached.

				   <button onclick="console.log(this)">Click me</button>

			   	(B) When the button is clicked, the `this` keyword refers to the `<button>` element itself.

			(III) `Event Listeners`:
			   	
				(A) When you attach event listeners using JavaScript, the context of `this` can vary depending on how the event listener is attached.

			   	(B) If you attach an event listener using the `addEventListener()` method, the `this` keyword inside the event handler function refers to the DOM element to which the event listener is attached.

			     	document.getElementById('myButton').addEventListener('click', function() {
			         	console.log(this); // 'this' refers to the DOM element with id 'myButton'
			     	});

			   (C) If you use arrow functions (`() => {}`) as event handlers, the lexical scope of `this` is preserved, and it refers to the context where the arrow function was defined, typically the global scope or the scope of the enclosing function. In this case, `this` does not refer to the DOM element.

			     	document.getElementById('myButton').addEventListener('click', () => {
			         	console.log(this); // 'this' refers to the global object or the enclosing function's scope
			     	});
			     	```

		(i) Binding

			(I) In JavaScript, binding refers to the process of associating a function with a particular context or object. It determines what the `this` keyword refers to within the function when it is invoked. Understanding binding is crucial for managing the context of functions, especially in situations where functions are passed around as values or used as callbacks.

			There are several ways to bind functions in JavaScript:

			(II) Implicit Binding:

				(A) When a function is called as a method of an object, the `this` keyword inside the function refers to the object on which the method was called.

			   	const person = {
			       	name: 'John',
			       	greet: function() {
			           	console.log('Hello, ' + this.name);
			       	}
			   	};

			   	person.greet(); // Output: Hello, John

			(III) Explicit Binding:

			   	(A) You can explicitly bind a function to a specific context using methods like `call()`, `apply()`, or `bind()`.

			   	(B) `<Function>.call(<`this` Value>, args...)` calls the Function with a specified Value of `this`

					const person1 = { name: 'John' };
			   		const person2 = { name: 'Jane' };

			   		function greet(msg) {
			    	   	console.log(`${msg} ${this.name}`);
			   		}

			   		greet.call(person1, 'Hello'); // Output: Hello, John
			   		greet.call(person2, 'Hi'); // Output: Hi, Jane

				(C) `<Function>.apply(<`this` value>, [args...])` function is similar to the call() function, except that it accepts arguments as an array or array-like object instead of as individual arguments.

					const person1 = { name: 'John' };
			   		const person2 = { name: 'Maria' };

			   		function greet(msg) {
			    	   	console.log(`${msg} ${this.name}`);
			   		}

			   		greet.apply (person1, ['Hello']); // Output: Hello, John
			   		greet.apply(person2, ['Hi']); // Output: Hi, Maria

				(D) `<Function>.bind()` function used for Hard Binding, returns a new function with the specified `this` value and, optionally, pre-set arguments, IT ensure that a function always uses a specific `this` value by explicitly binding.

					const person = {
						name: 'John'
					};

					function greet() {
						console.log('Hello, ' + this.name);
					}

					const boundGreet = greet.bind(person);
					boundGreet(); // Output: Hello, John

		(j) Understanding the behavior of the this keyword is crucial for writing maintainable and predictable code in JavaScript. It is essential to be aware of how it behaves in different contexts to avoid unexpected results.
	
	(iii) `delete` 
		
		(a) for Objects: removes a property from an object. If the property's value is an object and there are no more references to the object, the object held by that property is eventually released automatically.

			const Employee = {
			  	firstname: 'John',
			  	lastname: 'Doe',
			};

			console.log(Employee.firstname);
			// Expected output: "John"

			delete Employee.firstname;

			console.log(Employee.firstname);
			// Expected output: undefined

		(b) for Arrays: When you delete an array element, the array length is not affected. This holds even if you delete the last element of the array.

			const trees = ["redwood", "bay", "cedar", "oak", "maple"];
			delete trees[3];
			console.log(3 in trees); // false

	(iv) `in`

		(a) `in` operator returns true if the specified property is in the specified object or its prototype chain.

			// Arrays
			const trees = ["redwood", "bay", "cedar", "oak", "maple"];
			0 in trees; // returns true
			3 in trees; // returns true
			6 in trees; // returns false
			"bay" in trees; // returns false (you must specify the index number, not the value at that index)
			"length" in trees; // returns true (length is an Array property)
			Symbol.iterator in trees; // returns true

			// Predefined objects
			"PI" in Math; // returns true

			// Custom objects
			const mycar = { make: "Honda", model: "Accord", year: 1998 };
			"make" in mycar; // returns true
			"model" in mycar; // returns true
			
	(iv) `throw`

		(a) `throw` keyword in JavaScript is used to explicitly `throw` an exception. It is used within the `try...catch` block to handle and manage exceptions that might occur during the execution of the program. When an error condition arises, the `throw` statement is used to signal that an error has occurred and to stop the execution of the program.

		Here's an example to illustrate the use of the `throw` keyword:

			const divide = (x, y)=>{
			    if (y === 0) {
			        throw new Error("Division by zero is not allowed.");
			    }
			    return x / y;
			}

			try {
			    let result = divide(10, 0);
			    console.log("Result:", result);
			} catch (error) {
			    console.error("Error:", error.message);
			}

			in this example, the divide function checks if the divisor `y` is 0. If it is, an Error object is thrown with the message "Division by zero is not allowed." The try...catch block is then used to catch the thrown error, and the error message is logged to the console.

		(b) The throw statement is essential for custom error handling and allows you to create your own error messages, making your code more robust and easier to debug.
		
21. Promises
		
	(i) The `Promise` object represents the eventual result of an asynchronous operation. It has two main properties: state and result. The state can be either "pending," "fulfilled," or "rejected," and the result is the value that the `Promise` eventually resolves to or the reason for rejection.

	Promises have three states:

	(ii) Pending: Initial state, neither fulfilled nor rejected.
	(iii) Fulfilled: The operation completed successfully.
	(iv) Rejected: The operation failed.

	(v) The Promise object takes a function with two parameters, `resolve` and `reject`. The resolve function is called when the operation is successful, and the reject function is called when the operation fails.

	for Example:-

		const myPromise = new Promise((resolve, reject) => {
		  	// Simulating an asynchronous operation
		  	setTimeout(() => {
		    	const randomNumber = Math.random();

		    	if (randomNumber > 0.5) {
		      		resolve(randomNumber); // Operation succeeded

		    	} else {
		      		reject(new Error('Operation failed')); // Operation failed
		    	}
		  	}, 1000);
		});
			
		myPromise

		  	.then((result) => {
		    	console.log('The operation was successful. Result:', result);
		  	})
		  	.catch((error) => {
		    	console.error('The operation encountered an error:', error);
		  	});
			
		In this example, `myPromise` simulates an asynchronous operation that either resolves or rejects after a random time interval. The `then()` method is used to handle the successful operation, and the `catch()` method is used to handle any errors or rejections.

	(vi) Key properties of the Promise Object

		(I) State: A Promise has three possible states: pending, fulfilled, or rejected. When a Promise is created, it is in the pending state. When an operation is successful, the Promise transitions to the fulfilled state, and if an error occurs, it transitions to the rejected state.

		(II) Result: The result is the value that the Promise eventually resolves to. When a Promise is fulfilled, it returns a value. If it is rejected, it usually returns an Error object containing the reason for the rejection.

	(vii) Functions of Promise Object

		(a) `.then()`

			(I) `.then()`: It's used to handle the result of a Promise. When a Promise is resolved, the function passed to `.then()` is executed. This function can be used to handle the successful result of the asynchronous operation. It takes in a success callback function as an argument. for Example:-

				someAsyncOperation()
			  	.then((result) => {
			  		console.log('Operation successful: ' + result);
			  	})

		(b) `.catch()`

			(I)`.catch()`: It's used to handle errors in Promises. When a Promise is rejected, the function passed to .catch() is executed. This function can be used to handle any errors that occurred during the asynchronous operation. It takes in an error callback function as an argument. for Example:-

				someAsyncOperation()
			  	.then((result) => {
			  	  	console.log('Operation successful: ' + result);
			  	})
			  	.catch((error) => {
			  	  	console.error('An error occurred: ' + error);
			  	});

		(c) `finally()`
				
			(I) `finally()` Function is used to run some code after the Promise has been settled, regardless of whether it was fulfilled or rejected. This can be useful for cleanup operations that need to be performed no matter what the outcome of the Promise is.

				myPromise.finally(() => {
				  	console.log("Promise finally settled");
				});
			
	(viii) Promise Chaining

		(a) Promise chaining allows you to execute multiple asynchronous operations in a specific sequence. This technique is especially useful when you have dependent asynchronous tasks, where the result of one operation determines the execution of the next. Using `.then()` for promise chaining enables you to handle the fulfillment of a promise and then continue to the next operation based on the result. 
			
			Here is an example to illustrate how to chain promises using `.then()`:

			// A function that returns a promise after a delay
			const delay = (t) => {
				new Promise(resolve => setTimeout(resolve, t))
			};

			// Promise chaining with .then()

			delay(2000) // Wait for 2 seconds
			    .then(() => {
			        console.log('2 seconds have passed.');
			        return delay(3000); // Wait for another 3 seconds
			    })
			    .then(() => {
			        console.log('5 seconds have passed in total.');
			        return delay(1000); // Wait for 1 second
			    })
			    .then(() => {
			        console.log('6 seconds have passed in total.');
			        // Perform additional operations if necessary
			    });

			(I) In this example, the delay function returns a promise that resolves after a specified duration. By using `.then()` after each promise, you can create a chain of asynchronous operations. Each `.then(II)` block will wait for the previous promise to be fulfilled before executing the next one. This pattern allows you to manage asynchronous tasks in a synchronous manner, making the code easier to read and maintain.

	(ix) Promise API

		(a) `Promise.all()`
				
			(I) `Promise.all()` Functions takes an iterable of Promises as an input and returns a single Promise that resolves when all of the input Promises have resolved, or rejects if any of the Promises reject.

			for Example:-

				const promise1 = Promise.resolve("Promise 1 resolved");
				const promise2 = new Promise((resolve, reject) => {
					setTimeout(resolve, 2000, "Promise 2 resolved");
				});

				Promise.all([promise1, promise2])
					.then((values) => {
					    console.log(values);
					})
					.catch((error) => {
						console.error(error);
					});

			(II) `Promise.all()` Returns An array containing values of all the promises

		(b) `Promise.allSettled()`

			(I) `Promise.allSettled()` function is a utility method introduced in ECMAScript 2020 (ES11) for handling multiple promises simultaneously. Unlike `Promise.all()`, which immediately rejects upon any of the promises rejecting, `Promise.allSettled()` processes all the promises irrespective of whether they resolve or reject, making it easier to work with multiple asynchronous tasks. It returns a promise that resolves when all the input promises have settled.

				const promise1 = Promise.resolve(3);
				const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error'));
				const promise3 = new Promise((resolve) => setTimeout(resolve, 200, 'Done'));

				Promise.allSettled([promise1, promise2, promise3])
					.then((results) => {
						console.log(results)
						// returns an Array
					})

		(c) `Promise.race()`

			(I) `Promise.race()` function is a utility method in JavaScript used to handle multiple promises simultaneously. It takes an iterable of promises as an input and returns a single promise that resolves or rejects as soon as one of the input promises resolves or rejects. for Example:-

				const promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'one'));
				const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'two'));

				Promise.race([promise1, promise2])
				  	.then((value) => {
				    	console.log(value); // "two" is logged, as it is the first one to settle.
				  	})
				  	.catch((reason) => {
				    	// This is never called in this example.
				    	console.log(reason);
				  	});

				In this example, Promise.race() is used to race two promises, and it resolves or rejects with the value or reason of the first promise to settle, respectively.
			
		(d) `Promise.any()`

			(I) `Promise.any()` function in JavaScript is a utility method used to handle multiple promises simultaneously. It takes an iterable of promises as an input and returns a single promise. This promise is fulfilled if any of the promises in the iterable fulfills, and it is rejected only if all of the promises in the iterable are rejected. for Example :-

				const promise1 = new Promise((resolve, reject) => setTimeout(reject, 100, 'one'));
				const promise2 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'two'));

				Promise.any([promise1, promise2])
				  	.then((value) => {
				    	console.log(value); // "two" is logged, as it is the first one to fulfill.
				  	})
				  	.catch((error) => {
				    	console.log(error); // This is never called in this example.
				  	});

				In this example, `Promise.any()` is used to handle two promises. It resolves with the value of the first promise that fulfills, in this case, 'two'. If all the promises are rejected, it would throw an `AggregateError` containing all the rejection reasons.

		(e) `Promise.resolve(value)`: This method returns a `Promise` object that is resolved with the given value. If the value is a thenable (i.e., has a `then()` method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value. for Example:-

			const resolvedPromise = Promise.resolve('Resolved!');
			resolvedPromise.then((value) => {
			  console.log(value); // 'Resolved!' is logged.
			});

		(f) Promise.reject(reason): This method returns a Promise object that is rejected with the given reason. This is mainly used for error handling or indicating that an operation failed. for example:-

			const rejectedPromise = Promise.reject(new Error('Rejected!'));
			rejectedPromise.catch((reason) => {
			  console.error(reason); // 'Rejected!' is logged.
			});
	
22. Async/Await

	(i) `async` and `await` are keywords in JavaScript that work together to simplify the process of working with and writing asynchronous code. They make asynchronous code look and behave more like synchronous code, which is easier to read and maintain. These keywords were introduced in ES2017 (ES8) and have since become an integral part of modern JavaScript programming.

	(ii) `async` function:

		(a) The `async` keyword is used to define an asynchronous function. When a function is declared as `async`, it enables the use of the `await` keyword within the function body.
		(b) An `async` function always returns a promise. If the function explicitly returns a value, the promise will be resolved with that value. If the function throws an error, the promise will be rejected with the thrown error.
		(c) Asynchronous operations within an `async` function can be written in a way that appears synchronous, making the code more readable and easier to understand.

		for Example:-

			async function fetchData() {
			    try {
			        const response = await fetch('https://api.example.com/data');
			        const data = await response.json();
			        return data;
			    } catch (error) {
			        console.error('Error fetching data:', error);
			    }
			}

	(iii) `await` Keyword:

		(a) The `await` keyword is used within an async function to pause the execution of the function until the promise is settled.
		(b) When used with a promise, `await` waits for the promise to resolve, and it returns the resolved value. If the promise is rejected, it throws an error that can be caught using a try-catch block.
		(c) It's important to note that `await` can only be used within an async function. Using `await` outside of an async function will result in a syntax error.

		Example of using await within an async function:

			async function fetchUser() {
			    try {
			        const response = await fetch('https://api.example.com/user');
			        const user = await response.json();
			        console.log(user);
			    } catch (error) {
			        console.error('Error fetching user:', error);
			    }
			}
				
	(d) More Examples:-

		// Example 1: Using async/await with a simple asynchronous function
		async function getData() {
		    const response = await fetch('https://api.example.com/data');
		    const data = await response.json();
		    return data;
		}

		// Example 2: Using async/await to handle a promise
		function resolveAfter2Seconds() {
		    return new Promise(resolve => {
		        setTimeout(() => {
		            resolve('resolved');
		        }, 2000);
		    });
		}

		async function asyncCall() {
		    console.log('Calling');
		    const result = await resolveAfter2Seconds();
		    console.log(result);
		}

		// Example 3: Using async/await with error handling
		async function fetchUser() {
		    const response = await fetch('https://api.example.com/user');
		    if (!response.ok) {
		        throw new Error('Network response was not ok');
		    }
		    const user = await response.json();
		    return user;
		}

		In these examples, the async keyword is used to declare functions that can use the await keyword to pause the execution until a promise settles. The code within the async function looks synchronous but is actually asynchronous. It allows you to handle promises more intuitively, making the code easier to read and maintain.

23. Try..Catch

	(i) `try` and `catch` are used for error handling within your code. They allow you to attempt a block of code that might throw an error, and if an error is thrown, you can catch and handle it without interrupting the whole script execution.
	
	Here's how they work:

	(ii) `try`: This block allows you to define a block of code to be tested for errors. If an error occurs within the try block, it gets caught.

	(iii) `catch`: This block is used to handle the error. If any error occurs within the try block, it is caught by the catch block, allowing you to handle the error gracefully.

	(iv) Syntax:

		try{
			<Code Here>
		} catch( <error>){
			<Handle Error Here>
		}

	Here's a basic example to illustrate their usage:

		try {
		    // This is the block of code that will be attempted
		    
			let result = parseInt("ABC");

		    console.log(result); // If no error is thrown, this will be executed
		} catch (error) {
		    // If an error occurs in the try block, it will be caught here
		    console.error('An error occurred:', error);
		}

		In this example, `parseInt("ABC")` throws an error, the catch block will handle it, and the error message will be logged to the console. If no error occurs, the catch block is bypassed, and the result is logged normally.

		(a) `try` and `catch` can only catch errors that occur synchronously within the `try` block. Asynchronous errors, such as those inside a setTimeout() or a promise, will not be caught directly by the `try...catch` block and require special handling through promises or other error handling mechanisms.

	(iv) `finally`
		
		(a) keyword is used in conjunction with `try` and `catch` blocks in error handling. The `finally` block contains statements that will be executed regardless of whether an error is thrown or not. It is typically used to ensure that some code runs no matter what happens in the `try` and `catch` blocks.

		(b) Syntax:

			try{
				<Code to Run>
			} catch(<error>){
				<Handle The Error>
			} finally{
				<This Must Run!>
			}

		for Example:-

			function divideByTwo(number) {
			    try {
			        if (typeof number !== 'number') {
			            throw 'Input is not a number'; // Throwing a custom error message
			        }
			        return number / 2;
			    } catch (error) {
			        console.error('Error:', error);
			    } finally {
			        console.log('Function execution complete.'); // This will always run
			    }
			}
			
			// Example usage
			divideByTwo('not a number');
				
22. Errors

	(i) `Error` object in JavaScript represents an error that occurs during the execution of the code. It can be used to create custom error types or handle errors that occur in your code. Instances of the `Error` object can be thrown, caught, and used for structured error handling.

	The Error object has these properties:

	(ii) name: A string representing the name of the error.
	(iii) message: A human-readable description of the error.
	(iv) stack: A string representing the stack trace, which is a list of function calls that were in the execution at the point where the error occurred.

	Here's an example of creating and throwing a custom error using the `Error` object:

		// Custom error example
		try {
		    throw new Error('This is a custom error message');
		} catch (error) {
		    console.error('Error name:', error.name); // Output: Error
		    console.error('Error message:', error.message); // Output: This is a custom error message
		    console.error('Stack trace:', error.stack); // Output: stack trace information
		}

	(v) In this example, we're using the `Error` object to create and throw a custom error. The try...catch block is used to catch the error, and we're logging the properties of the `Error` object to the console.

	(vi) Custom Errors:

		(a) `throw` keyword is used to create custom errors, also known as user-defined or custom exceptions. Custom errors are used to handle specific types of errors that may occur in your code, providing more context and information about the error. Creating custom errors allows you to define your own error types with specific properties and behaviors.

		for Example:-

			function divideByTwo(number) {
			    if (typeof number !== 'number') {
			        throw 'Input is not a number'; // Throwing a custom error message
			    }
			    return number / 2;
			}

			// Example usage
			try {
			    let result = divideByTwo('not a number'); // This will throw the custom error
			    console.log('Result:', result);

			} catch (error) {
			    console.error('Error:', error);
			}

			In this Example, the divideByTwo function checks if the input is a number. If it's not a number, it throws a custom error message. The try...catch block is used to catch the error, and in this case, we simply log the error to the console.
	
23. Network

	(i) Fetch API

		(a) The Fetch API is a modern, versatile interface that provides a way to fetch resources asynchronously across the network. It offers a more powerful and flexible feature set compared to its predecessor, XMLHttpRequest. Fetch allows you to make network requests similar to XMLHttpRequest but with a simpler and more intuitive design. It is built on top of Promises, making it easier to work with, especially when dealing with asynchronous code.

		Here is a detailed explanation of the Fetch API:

		(b) Basic Usage: To make a simple GET request using the Fetch API, you can use the `fetch()` function. This function returns a Promise that resolves to the Response to that request, whether it is successful or not.

			fetch('https://api.example.com/data')
			  	.then(response => response.json())
			  	.then(data => console.log(data))
			  	.catch(error => console.error('Error:', error));

		(c) Request and Response Objects: Fetch allows you to work with the Request and Response objects, which provide extensive information about the request and response, including headers, status, statusText, and more.
		
		Getting:

		(d) Response Object (The Data we got from The Server):

			(I) Statuses

				(A) `Status`: The status code of the response (e.g., 200 for a successful request, 404 for a not found request, etc.).
				(B) `Status Text`: The status message corresponding to the status code (e.g., "OK" for 200).
				(C) `ok` Property: A boolean value indicating whether the response was successful (status in the range 200-299) or not.

			(II) Info

				(A) `URL`: The URL of the response.

			(V) Parsing Data

				(Note: Parsing Data is essential to get data in specific Formats)
				
				(A) `text()` Method: Returns a Promise that resolves with the response body as text.
				(B) `json()` function is used to extract JSON content from the response. It parses the response body as JSON and returns a Promise that resolves to the result of parsing the body text as JSON. This function is especially useful when dealing with APIs that return JSON data.

				(C) `Blob()` (FrontEnd exclusive): Returns a Promise that resolves with the response body as a Blob (binary large object), in other word an File.

					(async () => {
					    const Request = await fetch(URL);
					    const File = await Request.blob()
					})()

				(V) `arrayBuffer()` (BackEnd exclusive): Used to Receive File from Server-to-Server

					(async () => {
					    const Request = await fetch(URL);
					    const File = await Request.arrayBuffer()

						fs.writeFileSync('./myfile.jpg', File)
					})()

			(III) Sections

				(A) `Headers`: The headers associated with the response, which include information such as the content type and any custom headers.
				(B) `Body`: The response body, which contains the data received from the server. This can be in the form of text, JSON, or a Blob.

			(IV) Copying Data
				
				(D) `Clone()` Method: Creates a clone of the response object, allowing it to be used again in the code.
					
			for Example:-

				fetch('https://api.example.com/data')
				  	.then(response => {

				    	console.log('Status:', response.status); // Status code
				    	console.log('Status Text:', response.statusText); // Status text
				    	console.log('Headers:', response.headers); // Headers
				    	return response.json(); // Parsing response data as JSON

				  	})
				  	.then(data => console.log(data)) // Handling the JSON response
				  	.catch(error => console.error('Error:', error));

			(Note: You always Have to Use `.then()` function twice, One time for Parsing The data and status(status are optional), and the second time actually using it to perform some tasks)

			(XII) Understanding these properties and methods is essential for effectively handling requests and responses in the Fetch API. They provide developers with the necessary tools to work with network requests and process the data returned from the server.

		Sending:

		(e) Request Object (The Data we sent to The Server):

			(I) URL: The URL of the request, represented as a string.
			(II) Method: The HTTP method of the request (GET, POST, PUT, DELETE, etc.).
			(III) Headers: The headers associated with the request, which include information such as the content type and any custom headers.
			(IV) Body: The request body, which contains the data to be sent to the server. This can include data such as form data or JSON.
			(V) Mode: The mode of the request (e.g., cors, no-cors, same-origin).
			(VI) Credentials: Whether cookies, HTTP authentication, and client-side SSL certificates should be included with the request.
			(VII) Cache: The cache mode of the request (default, reload, no-cache, force-cache, or only-if-cached).
			(VIII) Redirect: The redirect mode of the request (follow, error, or manual).

			for Example:-

				// Creating a new `Request` object
				const request = new Request('https://api.example.com/data', {
				  	method: 'GET',
				  	headers: new Headers({
				    	'Content-Type': 'application/json'
				  	})
				});

				// Fetching using the created Request object

				fetch(request)
				  	.then(response => response.json())
				  	.then(data => console.log(data))
				  	.catch(error => console.error('Error:', error));

		(e) `options` Arguments
			
			(Note: If `options` argument is not defined then the request will simple be a Get Request)
			(I) `options` argument in the fetch API is an optional parameter that allows you to customize the properties of the request, such as the method, headers, body, mode, credentials, cache, redirect, and more. It provides a way to configure various aspects of the HTTP request that you're making. 
			
			Here's a breakdown of some commonly used options:
			
			(II) method (String): The HTTP request method, such as 'GET', 'POST', 'PUT', 'DELETE', etc.

				(A) `GET`: This method requests a representation of the specified resource. This method should only retrieve data and should have no other effect.

					fetch('https://example.com/data', {
					  	method: 'GET'
					})
					  	.then(response => response.json())
					  	.then(data => console.log(data))
					  	.catch(error => console.error('Error:', error));

				(B) `POST`: This method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.

					fetch('https://example.com/data', {
					  	method: 'POST',
					  	headers: {
					    	'Content-Type': 'application/json'
					  	},
					  	body: JSON.stringify({ name: 'John Doe' })
					})
					  	.then(response => response.json())
					  	.then(data => console.log(data))
					  	.catch(error => console.error('Error:', error));

				(C) `PUT`: This method replaces all current representations of the target resource with the request payload.

					fetch('https://example.com/data/123', {
					  	method: 'PUT',
					  	headers: {
					    	'Content-Type': 'application/json'
					  	},
					  	body: JSON.stringify({ name: 'Jane Doe' })
					})
					  	.then(response => response.json())
					  	.then(data => console.log(data))
					  	.catch(error => console.error('Error:', error));

				(D) `DELETE`: This method deletes the specified resource.

					fetch('https://example.com/data/123', {
					  	method: 'DELETE'
					})
					  	.then(response => response.text())
					  	.then(data => console.log(data))
					  	.catch(error => console.error('Error:', error));
					
				(E) `OPTIONS`: This method is used to describe the communication options for the target resource.

					fetch('https://example.com/data', {
					  	method: 'OPTIONS'
					})
					  	.then(response => response.text())
					  	.then(data => console.log(data))
					  	.catch(error => console.error('Error:', error));
					
				(F) `PATCH`: This method is used to apply partial modifications to a resource.

					fetch('https://example.com/data/123', {
					  	method: 'PATCH',
					  	headers: {
					    	'Content-Type': 'application/json'
					  	},
					  	body: JSON.stringify({ age: 30 })
					})
					  	.then(response => response.json())
					  	.then(data => console.log(data))
					  	.catch(error => console.error('Error:', error));

			(III) `headers` object: contains various properties and values that help control the HTTP request `headers`. Here are some of the common properties and their values that can be set within the `headers` object:

				(a) Content-Type: The` Content-Type` header specifies the media type of the resource. It is used to indicate the media type of the resource being sent or requested. Common values include 'application/json', 'text/plain', 'application/xml', etc.

					const headers = new Headers({
					  	'Content-Type': 'application/json'
					});

				(b) `Accept`: The `Accept` header specifies the media types that are acceptable for the response. It indicates the media type that the client is able to understand. Common values include 'application/json', 'text/plain', 'text/html', etc.

					const headers = new Headers({
					  	'Accept': 'application/json'
					});

				(c) `Authorization`: The `Authorization` header is used to provide authentication information, typically in the form of a token or credentials. It allows the client to authenticate itself with the server.

					const headers = new Headers({
					  'Authorization': 'Bearer <token>'
					});

				(d) `Cache-Control`: The `Cache-Control` header specifies directives for caching mechanisms in both requests and responses. It controls how and for how long the content should be cached.

					const headers = new Headers({
					  'Cache-Control': 'max-age=3600'
					});

				(e) `User-Agent`: The `User-Agent` header provides information about the user agent originating the request, such as the application type, operating system, and software vendor.
				
					const headers = new Headers({
					  	'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36'
					});

				(f) Custom Headers: You can also set custom headers as needed for your specific application requirements.

					const headers = new Headers({
					  'X-Custom-Header': 'custom-value'
					});
			
			(IV) body (Body): The body of the request. This property is used to send data in the request, usually when making a 'POST' or 'PUT' request.

				(A) the `body` object is used to include the `body` content of the HTTP request being sent to the server. The body can contain various types of data, such as JSON, text, Blob, FormData, or URLSearchParams. You can set the body property in the `fetch()` method to send data along with your request. Here are the common ways to use the body property:

				(B) Sending JSON Data: You can send JSON data in the body of a request by stringifying the JSON object and setting it as the value of the `body` property.

					const data = { username: 'example', password: 'example123' };

					const response = fetch(url, {
					  	method: 'POST',
					  	headers: {
					    	'Content-Type': 'application/json'
					  	},
					  	body: JSON.stringify(data)
					});

				(C) Sending Form Data: To send form data, you can use the `FormData` object to collect form fields and their values and then set it as the value of the `body` property.

					const formData = new FormData();
					formData.append('username', 'example');
					formData.append('password', 'example123');

					const response = fetch(url, {
					  	method: 'POST',
					  	body: formData
					});

				(D) Sending Plain Text:	If you want to send plain text, you can directly assign the text to the `body` property. 

					const textData = 'Hello, this is a text message!';
					const response = fetch(url, {
					  	method: 'POST',
					  	headers: {
					    	'Content-Type': 'text/plain'
					  	},
					 	body: textData
					});

				(E) Sending Binary Data: You can send binary data such as images or files using the `Blob` object.	

					const file = document.querySelector('input[type="file"]').files[0];
					const response = fetch(url, {
					  	method: 'POST',
					  	body: file
					});

				(F) The `body` property allows you to customize the data you want to send in the HTTP request. Make sure to set the appropriate `Content-Type` header in the `headers` property to match the type of data you are sending in the body.
			
			(V) mode (RequestMode): This property specifies the mode of the request. It can be 'cors', 'no-cors', 'same-origin', or 'navigate'.
			
			(VI) credentials (RequestCredentials): Determines whether the browser sends cookies with the request. It can be 'same-origin', 'include', or 'omit'.
			
			(VII) cache (RequestCache): This property specifies the cache mode for the request. It can be 'default', 'no-store', 'reload', 'no-cache', 'force-cache', or 'only-if-cached'.
			
			(VIII) redirect (RequestRedirect): Determines how redirects are handled. It can be 'follow', 'error', or 'manual'.
			
			(IX) referrer (String): Specifies the value of the referer HTTP header.
			
			(X) integrity (String): Allows you to specify the Subresource Integrity value of the request.
			
			(XI) window (Object): A reference to the global object. For web browsers, this would be the window object.
			
			(XII) signal (AbortSignal): An AbortSignal object used to communicate with a DOM request. It can be used to abort the request.
			
			(XIII) referrerPolicy (ReferrerPolicy): Specifies the referrer policy for the request.

			Here's an example of using the options argument in a fetch request:

				fetch('https://api.example.com/data', {
					  	method: 'POST',
					  	headers: {
					    	'Content-Type': 'application/json',
					    	'Authorization': 'Bearer token123'
					  	},
					  	body: JSON.stringify({
					    	username: 'exampleUser',
					    	password: 'examplePassword'
					  	}),
					  	mode: 'cors',
					  	credentials: 'include',
					  	cache: 'no-cache',
					  	redirect: 'follow',
					  	referrer: 'no-referrer'
					})
					.then(response => response.json())
					.then(data => console.log(data))
					.catch(error => console.error('Error:', error));
				
			(XI) The options argument is instrumental in tailoring the specifics of your network requests and responses, ensuring you have precise control over how the browser interacts with the remote server.

		(f) Error Handling: Fetch uses Promises, which means you can use `.then()` and `.catch()` to handle both successful and failed requests. You can check for errors and handle them appropriately.

		(g) Cross-Origin Requests: Fetch allows you to make cross-origin requests, which is essential when fetching resources from different domains. You can control this behavior using the mode option.

	(ii) Cookies

		(a) Cookies are small pieces of data that can be stored on a user's computer and are often used for tracking, session management, and user preferences.
		(b) `The document.cookie` property allows you to access and manipulate cookies associated with the current webpag

			// Get the value of a specific cookie
			let myCookie = document.cookie;

			// Add a new cookie
			document.cookie = "username=John; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/";

		(c) To create a new cookie, you set the `document.cookie` property to a string in the format "name=value". You can also specify additional cookie attributes like expiration date, path, and domain.

			document.cookie = "username=John; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/";

		(d) To read a cookie, you parse the `document.cookie` string to find the cookie with the desired name.

			function getCookie(name) {
			  	let cookies = document.cookie.split("; ");
			  	for (let i = 0; i < cookies.length; i++) {
			    	let cookie = cookies[i];
				    let parts = cookie.split("=");
				    if (parts[0] === name) {
			    	  	return decodeURIComponent(parts[1]);
			    	}
			  	}
			  	return null;
			}
			let username = getCookie("username");
			// The getCookie function extracts the value of a specific cookie by name

		(e) To update or delete a cookie, you set the document.cookie property to a new value or remove the cookie by setting its expiration date to the past.

			// Update a cookie's value
			document.cookie = "username=Jane";

			// Delete a cookie by setting its expiration to the past
			document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";

		(f) Cookies are widely used for various purposes, including user authentication, remembering user preferences, and tracking user behavior. However, it's important to be aware of privacy considerations and potential security risks when working with cookies, especially when dealing with sensitive information.

	(iii) `localStorage` property

		(a) The `localStorage` object in JavaScript allows you to store key-value pairs locally within the user's browser and it can survive almost everything including reload.
		
		Here are its key properties:

		(b) `localStorage.setItem(key, value)`: This method sets a key-value pair in the `localStorage`. If the key already exists, it will update the value.

			localStorage.setItem('name', 'John');

		(c) `localStorage.getItem(key)`: This method retrieves the value associated with the provided key from the `localStorage`.

			const name = localStorage.getItem('name');
			console.log(name); // Output: John

		(d) `localStorage.removeItem(key)`: This method removes the key-value pair associated with the provided key from the `localStorage`.

			localStorage.removeItem('name');

		(e) `localStorage.key(index)`: This method returns key at a specific index.
			
			localStorage.setItem("name", "James");
			console.log(localStorage.key(0)) // prints: "name"

		(f) `localStorage.clear()`: This method clears all the key-value pairs stored in the `localStorage`.

			localStorage.clear();

		(g) `localStorage.length`: This property returns the number of items stored in the `localStorage`.

			console.log(localStorage.length);

		(h) The `localStorage` object allows you to store data persistently in the user's browser even after the browser is closed. It is a valuable tool for storing user-specific data or settings within a web application. However, be cautious with the amount of data you store, as browsers typically have limits on the amount of data that can be stored using `localStorage`.

		(NOTE: `localStorage` can survive everything even after browser has been closed)

	(iv) `sessionStorage` object
		
		(a) `sessionStorage` object in JavaScript allows you to store key-value pairs for a single session. Data stored in `sessionStorage` persists only for the duration of the page session. When the tab is closed, the data is cleared.
		
		(b) It's properties are exactly the same as `localStorage`s properties so it would be a time waste to explain them again

	(v) Storage Event

		(a) The `storage` event in JavaScript is triggered when changes are made to the `localStorage` or `sessionStorage` objects. These changes can originate from the current window or other windows or tabs running in the same origin. The event allows scripts to track changes to the storage area, enabling real-time synchronization between multiple tabs or windows.

		Here is a basic example of using the `storage` event:


			// Event listener for the 'storage' event
			window.addEventListener('storage', function(event) {
			    if (event.storageArea === sessionStorage) {
			        console.log('sessionStorage key: ' + event.key + ' was changed from ' + event.oldValue + ' to ' + event.newValue + ' in another tab!');
			    } else if (event.storageArea === localStorage) {
			        console.log('localStorage key: ' + event.key + ' was changed from ' + event.oldValue + ' to ' + event.newValue + ' in another tab!');
			    } else {
			        console.log('Some key was changed in another tab!');
			    }
			});

		(b) In the event handler, you can check the `storageArea` property to determine whether the changes were made in `localStorage` or `sessionStorage`. The `event.key`, `event.oldValue`, and `event.newValue` properties provide information about the changed key, its old value, and its new value, respectively.
			
			Individual Explaination:

			(I) `key`: The name of the key that was changed.
			(II) `oldValue`: The old value of the key before the change.
			(III) `newValue`: The new value of the key after the change.
			(IV) `url`: The URL of the document that initiated the change.
			(V) `storageArea`: Represents either localStorage or sessionStorage object that was affected.
			(VI) `storage`: The Storage object that was affected.
			(VII) `key`: A string that is the named key or index of the property to be set.

		(c) The storage event is particularly useful in scenarios where you need to maintain data consistency across different tabs or windows in a web application. It helps synchronize data in real time, ensuring that any changes made in one tab are reflected in others.

	(vi) Statuses

		Format:

			Status Code, Status Text, Description
				↓			↓			   ↓
			   200			Ok,        	Success
 
    	(a) Informational responses (100 – 199)
			
			(I) 100 `Continue`
				(A) This interim response indicates that the client should continue the request or ignore the response if the request is already finished.
			(II) 101 `Switching Protocols`
				(A) This code is sent in response to an Upgrade request header from the client and indicates the protocol the server is switching to.
			(III) 102 `Processing (WebDAV)`
				(A) This code indicates that the server has received and is processing the request, but no response is available yet.
			(IV) 103 `Early Hints`
				(A) This status code is primarily intended to be used with the Link header, letting the user agent start preloading resources while the server prepares a response or preconnect to an origin from which the page will need resources.

    	(b) Successful responses (200 – 299)

			(I) 200 OK
			    (A) The request succeeded. The result meaning of "success" depends on the HTTP method:

			        I. GET: The resource has been fetched and transmitted in the message body.
			        II. HEAD: The representation headers are included in the response without any message body.
			        III. PUT or POST: The resource describing the result of the action is transmitted in the message body.
			        I. TRACE: The message body contains the request message as received by the server.
			(II) 201 `Created`
			    (A) The request succeeded, and a new resource was created as a result. This is typically the response sent after POST requests, or some PUT requests.
			(III) 202 `Accepted`
			    (A) The request has been received but not yet acted upon. It is noncommittal, since there is no way in HTTP to later send an asynchronous response indicating the outcome of the request. It is intended for cases where another process or server handles the request, or for batch processing.
			(IV) 203 `Non-Authoritative Information`
			    (A) This response code means the returned metadata is not exactly the same as is available from the origin server, but is collected from a local or a third-party copy. This is mostly used for mirrors or backups of another resource. Except for that specific case, the 200 OK response is preferred to this status.
			(V) 204 `No Content`
			    (A) There is no content to send for this request, but the headers may be useful. The user agent may update its cached headers for this resource with the new ones.
			(VI) 205 `Reset Content`
			    (A) Tells the user agent to reset the document which sent this request.
			(VII) 206 `Partial Content`
			    (A) This response code is used when the Range header is sent from the client to request only part of a resource.
			(VIII) 207 `Multi-Status (WebDAV)`
			    (A) Conveys information about multiple resources, for situations where multiple status codes might be appropriate.
			(IX) 208 `Already Reported (WebDAV)`
			    (A) Used inside a <dav:propstat> response element to avoid repeatedly enumerating the internal members of multiple bindings to the same collection.
			(X) 226 `IM Used (HTTP Delta encoding)`
			    (A) The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.

    	(c) Redirection messages (300 – 399)

			(I) 300 `Multiple Choices`
			    (A) The request has more than one possible response. The user agent or user should choose one of them. (There is no standardized way of choosing one of the responses, but HTML links to the possibilities are recommended so the user can pick.)
			(II) 301 `Moved Permanently`
			    (A) The URL of the requested resource has been changed permanently. The new URL is given in the response.
			(III) 302 `Found`
			    (A) This response code means that the URI of requested resource has been changed temporarily. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.
			(IV) 303 `See Other`
			    (A) The server sent this response to direct the client to get the requested resource at another URI with a GET request.
			(V) 304 `Not Modified`
			    (A) This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.
			(VII) 305 `Use Proxy Deprecated`
			    (A) Defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.
			(VIII) 306 `unused`
			    (A) This response code is no longer used; it is just reserved. It was used in a previous version of the HTTP/1.1 specification.
			(IX) 307 `Temporary Redirect`
			    (A) The server sends this response to direct the client to get the requested resource at another URI with the same method that was used in the prior request. This has the same semantics as the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
			(X) 308 `Permanent Redirect`
			    (A) This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.

    	(d) Client error responses (400 – 499)
 
			(I) 400 `Bad Request`
			    (A) The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).
			(II) 401 `Unauthorized`
			    (A) Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response.
			(III) 402 `Payment Required Experimental`
			    (A) This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists.
			(IV) 403 `Forbidden`
			    (A) The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401 Unauthorized, the client's identity is known to the server.
			(V) 404 `Not Found`
			    (A) The server cannot find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 Forbidden to hide the existence of a resource from an unauthorized client. This response code is probably the most well known due to its frequent occurrence on the web.
			(VI) 405 `Method Not Allowed`
			    (A) The request method is known by the server but is not supported by the target resource. For example, an API may not allow calling DELETE to remove a resource.
			(VII) 406 `Not Acceptable`
			    (A) This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content that conforms to the criteria given by the user agent.
			(VIII) 407 `Proxy Authentication Required`
			    (A) This is similar to 401 Unauthorized but authentication is needed to be done by a proxy.
			(IX) 408 `Request Timeout`
			    (A) This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.
			(X) 409 `Conflict`
			    (A) This response is sent when a request conflicts with the current state of the server.
			(XI) 410 `Gone`
			    (A) This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code.
			(XII) 411 `Length Required`
			    (A) Server rejected the request because the Content-Length header field is not defined and the server requires it.
			(XIII) 412 `Precondition Failed`
			    (A) The client has indicated preconditions in its headers which the server does not meet.
			(XIV) 413 `Payload Too Large`
			    (A) Request entity is larger than limits defined by server. The server might close the connection or return an Retry-After header field.
			(XV) 414 `URI Too Long`
			    (A) The URI requested by the client is longer than the server is willing to interpret.
			(XVI) 415 `Unsupported Media Type`
			    (A) The media format of the requested data is not supported by the server, so the server is rejecting the request.
			(XVII) 416 `Range Not Satisfiable`
			    (A) The range specified by the Range header field in the request cannot be fulfilled. It's possible that the range is outside the size of the target URI's data.
			(XVIII) 417 `Expectation Failed`
			    (A) This response code means the expectation indicated by the Expect request header field cannot be met by the server.
			(XIX) 418 `I'm a teapot`
			    (A) The server refuses the attempt to brew coffee with a teapot.
			(XX) 421 `Misdirected Request`
			    (A) The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.
			(XXI) 422 `Unprocessable Content (WebDAV)`
			    (A) The request was well-formed but was unable to be followed due to semantic errors.
			(XXII) 423 `Locked (WebDAV)`
			    (A) The resource that is being accessed is locked.
			(XXIII) 424 `Failed Dependency (WebDAV)`
			    (A) The request failed due to failure of a previous request.
			(XXIV) 425 `Too Early Experimental`
			    (A) Indicates that the server is unwilling to risk processing a request that might be replayed.
			(XXV) 426 `Upgrade Required`
			    (A) The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an Upgrade header in a 426 response to indicate the required protocol(s).
			(XXVI) 428 `Precondition Required`
			    (A) The origin server requires the request to be conditional. This response is intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
			(XXVII) 429 `Too Many Requests`
			    (A) The user has sent too many requests in a given amount of time ("rate limiting").
			(XXVIII) 431 `Request Header Fields Too Large`
			    (A) The server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.
			(XXIX) 451 `Unavailable For Legal Reasons`
			    (A) The user agent requested a resource that cannot legally be provided, such as a web page censored by a government.

    	(e) Server error responses (500 – 599)

			(I) 500 `Internal Server Error`
			    (A) The server has encountered a situation it does not know how to handle.
			(II) 501 `Not Implemented`
			    (A) The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.
			(III) 502 `Bad Gateway`
			    (A) This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.
			(IV) 503 `Service Unavailable`
			    (A) The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This response should be used for temporary conditions and the Retry-After HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.
			(V) 504 `Gateway Timeout`
			    (A) This error response is given when the server is acting as a gateway and cannot get a response in time.
			(VI) 505 `HTTP Version Not Supported`
			    (A) The HTTP version used in the request is not supported by the server.
			(VII) 506 `Variant Also Negotiates`
			    (A) The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.
			(VIII) 507 `Insufficient Storage (WebDAV)`
			    (A) The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.
			(IX) 508 `Loop Detected (WebDAV)`
			    (A) The server detected an infinite loop while processing the request.
			(X) 510 `Not Extended`
			    (A) Further extensions to the request are required for the server to fulfill it.
			(XI) 511 `Network Authentication Required`
			    (A) Indicates that the client needs to authenticate to gain network access.

Section: Object Oriented Programming

24. Prototypes

	(i) `__proto__`

		(a) `__proto__` property is a part of the prototype-based inheritance model. Each object in JavaScript has a prototype, which can be accessed using the `__proto__` property. It allows an object to access properties and methods from its prototype. When a property or method is accessed on an object, JavaScript first looks for it on the object itself. If it's not found, it then looks at the object's prototype, and continues up the prototype chain until the property or method is found or the end of the chain is reached (which is usually the `Object.prototype`).

		(b) While using `__proto__` is not encouraged for production code due to performance reasons, you can use it for educational purposes or for understanding the underlying prototype chain. Instead of using `__proto__`, it's recommended to use `Object.getPrototypeOf()` and `Object.setPrototypeOf()` to get and set the prototype of an object, respectively.

		Here's a simple example of how `__proto__` works:

			// Creating a simple object
			let car = {
			  	make: 'Toyota',
			  	model: 'Corolla'
			};

			// Creating a prototype object
			let vehicle = {
			  	wheels: 4,
			  	color: 'black'
			};

			// Setting the prototype of the car object
			car.__proto__ = vehicle;

			// Accessing properties from the prototype
			console.log(car.color); // 'black'
			console.log(car.wheels); // 4

			In modern JavaScript, you can also use classes and the `extends` keyword for more readable and manageable code when dealing with inheritance and prototypes.

	(ii) `prototype` Object

		(a) `prototype` object is a fundamental concept related to how inheritance is implemented. Every JavaScript object has a `prototype`, which is used for inheritance. The `prototype` can be thought of as a blueprint for the object, defining its properties and methods. When a property or method is accessed on an object, JavaScript first checks if the object itself has that property or method. If it doesn't, it looks at the object's `prototype`, and continues up the `prototype` chain until the property or method is found or the end of the chain is reached.

		(b) The `prototype` property is specific to constructor functions and is not directly accessible on instances of objects. It's used as a template from which other objects are created. When a function is defined in JavaScript, it automatically gets a `prototype` property. This property is where all the properties and methods that should be available to instances of that function are defined.

		Here's an Example:-

			// Creating a constructor function
			function Person(name, age) {
			  	this.name = name;
			  	this.age = age;
			}

			// Adding a method to the prototype of the constructor function
			Person.prototype.introduce = function() {
			  	console.log(`Hi, my name is ${this.name} and I am ${this.age} years old.`);
			};

			// Creating an instance of the Person object
			const person1 = new Person('John', 30);

			// Calling the introduce method
			person1.introduce(); // Hi, my name is John and I am 30 years old.

			In this example, the `prototype` property is used to add a method (`introduce`) to the Person constructor function, making it accessible to all instances created from it.

25. Objects (Revisited)

	(i) `Object` object is a built-in global object that serves as the base for all other objects. It provides various utility functions and properties for creating and manipulating objects.
	
	Here are some of the commonly used properties and methods of the `Object` object, along with examples:
	
	(ii) `Object.assign(target, ...sources)`: This method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It returns the target object.

		const target = { a: 1, b: 2 };
		const source = { b: 4, c: 5 };

		const mergedObject = Object.assign(target, source);
		console.log(mergedObject); // { a: 1, b: 4, c: 5 }

	(iii)` Object.create(proto, [propertiesObject])`: This method creates a new object with the specified prototype object and properties.

		const person = {
		  	isHuman: false,
		  	introduction: ()=>{
		    	console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
		  	}
		};

		const me = Object.create(person);
		me.name = 'John';
		me.isHuman = true;

		me.introduction(); // My name is John. Am I human? true

	(iv) `Object.keys(obj)`: This method returns an array of a given object's own enumerable property names.

		const car = { make: 'Toyota', model: 'Corolla', year: 2020 };
		const keys = Object.keys(car);
		console.log(keys); // ['make', 'model', 'year']

	(v) `Object.values(obj)`: This method returns an array of a given object's own enumerable property values.

		const car = { make: 'Toyota', model: 'Corolla', year: 2020 };
		const entries = Object.entries(car);
		console.log(entries); // [['make', 'Toyota'], ['model', 'Corolla'], ['year', 2020]]

	(vi) `Object.entries(obj)`: This method returns an array of a given object's own enumerable property [key, value] pairs.

		const car = { make: 'Toyota', model: 'Corolla', year: 2020 };
		const entries = Object.entries(car);
		console.log(entries); // [['make', 'Toyota'], ['model', 'Corolla'], ['year', 2020]]

	(vii) `Object.freeze(obj)`: This method freezes an object, preventing new properties from being added to it, existing properties from being removed, or existing properties from being changed.

		const obj = {
		  	property: 42
		};
		
		Object.freeze(obj);
		obj.property = 33; // Throws an error in strict mode
		console.log(obj.property); // 42
		
	(viii) `Object.seal(obj)`: This method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable.

		const obj = {
		  	property: 42
		};

		Object.seal(obj);
		obj.property = 33; // Works fine
		delete obj.property; // Throws an error in strict mode
		console.log(obj.property); // 33
		
	(ix) `Object.is(obj1, obj2)`: This method determines whether two values are the same value. This is similar to the triple equals (`===`) operator, but with a few special cases for `NaN` and `-0`.

		console.log(Object.is('foo', 'foo')); // true
		console.log(Object.is(window, window)); // true

		console.log(Object.is('foo', 'bar')); // false
		console.log(Object.is([], [])); // false

	(x) `Object.getPrototypeOf(obj)`: This method returns the prototype of the specified object.

		const person = {
		  	name: 'John',
		  	age: 30
		};

		const prototype = Object.getPrototypeOf(person);
		console.log(prototype); // {}

26. Classes

	(i) classes were introduced in ECMAScript 2015 (ES6) as a syntactical sugar over the prototype-based inheritance model. They provide a more straightforward and clearer way to create objects and deal with inheritance. Under the hood, classes are primarily constructor functions and prototypes. They make it easier to create object blueprints, which can be used to create new instances of objects.

	Here's an example of how classes are used in JavaScript:

		// Defining a simple class
		class Car {
		  	constructor(make, model) {
		    	this.make = make;
		    	this.model = model;
		  	}

		  	// Adding a method to the class
		  	displayInfo() {
		    	console.log(`This is a ${this.make} ${this.model}.`);
		  	}
		}

		// Creating an instance of the class
		const myCar = new Car('Toyota', 'Corolla');

		// Calling the method on the instance
		myCar.displayInfo(); // This is a Toyota Corolla.

		In this example, the `Car` class has a constructor method that is used to initialize object properties, and a `displayInfo` method that is shared among all instances of the `Car` class.

	(ii) `extends` keyword
		
		(a) One of the benefits of using classes is that they allow for easy implementation of inheritance through the `extends` keyword. This enables one class to inherit properties and methods from another. 
		
		for example:-

			// Creating a subclass that extends the Car class
			class ElectricCar extends Car {
			  	constructor(make, model, batteryCapacity) {
			    	super(make, model);
			    	this.batteryCapacity = batteryCapacity;
			  	}

			  	// Adding a method to the subclass
			  	displayBatteryCapacity() {
			    	console.log(`This electric car has a battery capacity of ${this.batteryCapacity} kWh.`);
			  	}
			}

			// Creating an instance of the subclass
			const myElectricCar = new ElectricCar('Tesla', 'Model 3', 75);

			// Calling methods from the superclass and subclass
			myElectricCar.displayInfo(); // This is a Tesla Model 3.
			myElectricCar.displayBatteryCapacity(); // This electric car has a battery capacity of 75 kWh.
		
	(iii) Methods:

		(a) `Constructor` Method: The `constructor` method is a special method that is used for creating and initializing an object created with a class. It is called automatically when a new instance of the class is created.

			class Car {
			  	constructor(make, model) {
			    	this.make = make;
			    	this.model = model;
			  	}
			}
			(Note: Constructors always runs whenever the object is called)

		(b) Instance Methods: These are the regular functions defined inside a class. They can be called on instances of the class and can access the instance properties using the `this` keyword.

			class Car {
			  	constructor(make, model) {
			    	this.make = make;
			    	this.model = model;
			  	}

			  	displayInfo() {
			    	console.log(`This is a ${this.make} ${this.model}.`);
			  	}
			}

		(c) `super` function, calls the constructor of the Parent/Base Class

			class Rectangle {
			  	constructor(height, width) {
			    	this.name = "Rectangle";
			    	this.height = height;
			    	this.width = width;
			  	}
			  	sayName() {
			    	console.log(`Hi, I am a ${this.name}.`);
			  	}
			  	get area() {
			    	return this.height * this.width;
			  	}
			  	set area(value) {
			    	this._area = value;
			  	}
			}

			class Square extends Rectangle {
			  	constructor(length) {
			    	// Here, it calls the parent class's constructor with lengths
			    	// provided for the Rectangle's width and height
			    	super(length, length);

			    	// Note: In derived classes, super() must be called before you
			    	// can use 'this'. Moving this to the top causes a ReferenceError.
			    	this.name = "Square";
			  	}
			}

		(d) Static Methods: These methods are called on the class itself rather than on instances of the class. They are often used for utility functions that are not tied to any specific instance data.

			class Animal{
				constructor(name){
			        this.name = Animal.formatedName(name);
			    }
				get name(){
					return this.name
				}
			    static formatedName(_name){
			    	return _name[0].toUpperCase() + _name.slice(1, _name.length)
			        console.log(this.name)
			    }
			}
			let cat = new Animal("lavender")

			cat.name() : Lavender

		(e) Getter and Setter Methods: These methods are used to define a property of an object, and they can be used to get or set the value of that property. They provide a way to define custom behavior when an object property is accessed or modified.

			(WARNING: using this.<property> requires you to use a character like `_` or `#` to Avoid Call Stack Error and Name collisions)

			class Car {
			  	constructor(make, model) {
			    	this._make = make;
			    	this._model = model;
			  	}

			  	get make() {
			    	return this._make;
			  	}

			  	set make(newMake) {
			    	this._make = newMake;
			  	}
			}

			// here's Another Example:-

			class ClassWithGetSet {
			  	msg = "hello world";
			  	get msg() {
			    	return this._msg;
			  	}
			  	set msg(x) {
			    	this._msg = `hello ${x}`;
			  	}
			}

			const instance = new ClassWithGetSet();
			console.log(instance.msg); // "hello world"

			instance.msg = "cake";
			console.log(instance.msg); // "hello cake"

		(f) `instanceof` Checks if The Class/Method is a part of The Class

			(I) Syntax:

				object instanceof constructor

			(II) Example:

				// Creating a Class
				class Car{
					constructor(name, model){
						this.name = name;
						this.model = model;
					}
				}
				
				let NewCar = new Car("name","model")
				console.log(NewCar instanceof Car)  // True
				console.log(NewCar instanceof Car)  // True

				(Note: It'll return `true` even if the class is Inherited)

Section: High-End/Advance JavaScript

27.  Strict Mode

	(i) Strict mode is a feature in JavaScript that allows you to place a program, or a function, in a "strict" operating context. When strict mode is enabled, the JavaScript engine enforces a stricter set of rules and generates more exceptions for common coding errors or "unsafe" actions. It helps developers write cleaner and more secure code by catching potential errors and preventing certain actions that may lead to unexpected behavior.

	(ii) To enable strict mode, you simply add the string literal `"use strict";` at the beginning of a script or a function body. When placed at the beginning of a script, it applies to the entire script. When placed at the beginning of a function body, it applies to the function and its inner functions (if any).
	
	(iii) Enabling Strict Mode
	
		(a) `Script-level strict mode:`

	   		"use strict";

	   		// Your JavaScript code here

		(b) Function-level strict mode:

	   		function myFunction() {
	       		"use strict";

	       		// Your JavaScript code here
	   		}
	
	(iv) Strict mode enables the following changes and enhancements to the JavaScript language:
	
		(a) `Catching silent errors`: In non-strict mode, JavaScript may silently fail or behave unexpectedly in certain situations. Strict mode makes these errors explicit by throwing exceptions.

		(b) `Preventing undeclared variables`: In strict mode, using variables without declaring them first with `var`, `let`, or `const` will throw a reference error.

		(c) `Preventing duplicate property names`: In strict mode, you cannot define multiple properties with the same name in an object literal.

		(d) `Changing the meaning of `this``: In strict mode, the value of `this` inside a function is `undefined` if the function is called without an object context.

		(e) `Disabling `with` statement`: The `with` statement is not allowed in strict mode, as it can lead to confusion and potential security issues.

		(f) `Restricting the use of `eval``: In strict mode, the use of `eval` as a variable, function name, or parameter name is not allowed.

		(g) `Making `arguments` immutable`: In strict mode, changes to the `arguments` object inside a function do not affect the corresponding named parameters.
	
	(v) Using strict mode is recommended for all JavaScript codebases, as it helps prevent common programming mistakes, makes the code easier to optimize by the JavaScript engine, and ensures more predictable behavior across different environments and implementations of JavaScript.

28. IIFE

	(i) An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined

	(ii) Syntax:

		(function () {
		  // …
		})();

		(() => {
		  // …
		})();

		(async () => {
		  // …
		})();

	(iii) It is a design pattern which is also known as a `Self-Executing Anonymous Function` and contains two major parts:

		(a) The first is the anonymous function with lexical scope enclosed within the Grouping Operator `()`. This prevents accessing variables within the IIFE idiom as well as polluting the global scope.
		(b) The second part creates the immediately invoked function expression () through which the JavaScript engine will directly interpret the function.

	(iv) Use cases

		(a) Avoid polluting the global namespace
			
			(I) Because our application could include many functions and global variables from different source files, it's important to limit the number of global variables. If we have some initiation code that we don't need to use again, we could use the IIFE pattern. As we will not reuse the code again, using IIFE in this case is better than using a function declaration or a function expression.

				(() => {
				  // some initiation code
				  let firstVariable;
				  let secondVariable;
				})();

				// firstVariable and secondVariable will be deleted after the function is executed.

		(a) Execute an async function
			
			(I) An async IIFE allows you to use await and for-await even in older browsers and JavaScript runtimes that have no top-level await:

				const getFileStream = async (url) => {
				  // implementation
				};

				(async () => {
				  const stream = await getFileStream("https://domain.name/path/file.ext");
				  for await (const chunk of stream) {
				    console.log({ chunk });
				  }
				})();
		
29. Destructuring assignment
	
	(i) The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.

		let a, b, rest;
		[a, b] = [10, 20];

		console.log(a);
		// Expected output: 10

		console.log(b);
		// Expected output: 20

		[a, b, ...rest] = [10, 20, 30, 40, 50];

		console.log(rest);
		// Expected output: Array [30, 40, 50]

	(ii) Syntax:

		const [a, b] = array;
		const [a, , b] = array;
		const [a = aDefault, b] = array;
		const [a, b, ...rest] = array;
		const [a, , b, ...rest] = array;
		const [a, b, ...{ pop, push }] = array;
		const [a, b, ...[c, d]] = array;

		const { a, b } = obj;
		const { a: a1, b: b1 } = obj;
		const { a: a1 = aDefault, b = bDefault } = obj;
		const { a, b, ...rest } = obj;
		const { a: a1, b: b1, ...rest } = obj;
		const { [key]: a } = obj;

		let a, b, a1, b1, c, d, rest, pop, push;
		[a, b] = array;
		[a, , b] = array;
		[a = aDefault, b] = array;
		[a, b, ...rest] = array;
		[a, , b, ...rest] = array;
		[a, b, ...{ pop, push }] = array;
		[a, b, ...[c, d]] = array;

		({ a, b } = obj); // parentheses are required
		({ a: a1, b: b1 } = obj);
		({ a: a1 = aDefault, b = bDefault } = obj);
		({ a, b, ...rest } = obj);
		({ a: a1, b: b1, ...rest } = obj);
	
	(iii) Description

		(a) The destructuring assignment uses similar syntax but uses it on the left-hand side of the assignment instead. It defines which values to unpack from the sourced variable.

			const x = [1, 2, 3, 4, 5];
			const [y, z] = x;
			console.log(y); // 1
			console.log(z); // 2

		(b) Similarly, you can destructure objects on the left-hand side of the assignment.

			const obj = { a: 1, b: 2 };
			const { a, b } = obj;
			// is equivalent to:
			// const a = obj.a;
			// const b = obj.b;

	(iv) spread operator (...)
		
		(a) operater allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

			function sum(x, y, z) {
			  return x + y + z;
			}

			const numbers = [1, 2, 3];

			console.log(sum(...numbers));
			// Expected output: 6
	
30. Scopes

	(i) The scope is the current context of execution in which values and expressions are "visible" or can be referenced. If a variable or expression is not in the current scope, it will not be available for use. Scopes can also be layered in a hierarchy, so that child scopes have access to parent scopes, but not vice versa.
	
	(ii) JavaScript has the following kinds of scopes:

		(a) Global scope: The default scope for all code running in script mode.
			
			(I) Module scope: The scope for code running in module mode.

		(b) Local scope:

			(I) Function scope: The scope created with a function.

			In addition, variables declared with `let` or `const` can belong to an additional scope (in case if you're wondering `var` keyword belongs to Global Scope):

			(II) Block scope: The scope created with a pair of curly braces (a block).
		
	(iii) Scopes in Detail with Examples 
		
		(a) A function creates a scope, so that (for example) a variable defined exclusively within the function cannot be accessed from outside the function or within other functions. For instance, the following is invalid:

			function exampleFunction() {
			  	const x = "declared inside function"; // x can only be used in `exampleFunction`
			  	console.log("Inside function");
			  	console.log(x);
			}

			console.log(x); // Causes error

		(b) However, the following code is valid due to the variable being declared outside the function, making it global:

			const x = "some text";

			function exampleFunction() {
			  	console.log("Inside function");
			  	console.log(x);
			}

			exampleFunction();
			console.log("Outside function");
			console.log(x); // Output: "declared outside function"

		(c) Blocks only scope `let` and `const` declarations, but not `var` declarations.

			{
			  var x = 1;
			}
			console.log(x); // 1

			// on the other hand
			
			{
			  	const x = 1;
			}
			console.log(x); // ReferenceError: x is not defined

31. Hoisting
	
	(i) JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables, classes, or imports to the top of their scope, prior to execution of the code.
	
	(ii) Hoisting is not a term normatively defined in the ECMAScript specification. The spec does define a group of declarations as HoistableDeclaration, but this only includes `function`, `function*`, `async function`, and `async function*` declarations. Hoisting is often considered a feature of `var` declarations as well, although in a different way. In colloquial terms, any of the following behaviors may be regarded as hoisting:

		(a) Being able to use a variable's value in its scope before the line it is declared. ("Value hoisting")
		(b) Being able to reference a variable in its scope before the line it is declared, without throwing a ReferenceError, but the value is always undefined. ("Declaration hoisting")
		(c) The declaration of the variable causes behavior changes in its scope before the line in which it is declared.
		(d) The side effects of a declaration are produced before evaluating the rest of the code that contains it.

	(iii) Some prefer to see `let`, `const`, and `class` as non-hoisting, because the `temporal dead zone` strictly forbids any use of the variable before its declaration. This dissent is fine, since hoisting is not a universally-agreed term. However, the temporal dead zone can cause other observable changes in its scope, which suggests there's some form of hoisting:

		// The following works fine
		const x = 1;
		{
		  console.log(x); // 1
		}
		
		// But
		const y = 1;
		{
		  console.log(y); // ReferenceError: Cannot access 'y' before initialization
		  const y = 2;
		}

		// Here's another example:
		console.log(a) // output: undefined

		var a = 8;
		console.log(a) // output: 8

		(Note: using `var` for declaration makes the variable declared already by hoisting with the value of `undefined` and it'll stay like that until the line of declaration is reached AKA initialized)

32. Closures

	(i) A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.

	(ii) Lexical scoping: Consider the following example code:

		function init() {
		  	var name = "Mozilla"; // name is a local variable created by init
		  	function displayName() {
		    	// displayName() is the inner function, that forms the closure
		    	console.log(name); // use variable declared in the parent function
		  	}
		  	displayName();
		}
		init();

		`init()` creates a local variable called name and a function called `displayName()`. The `displayName()` function is an inner function that is defined inside `init()` and is available only within the body of the `init()` function. Note that the `displayName()` function has no local variables of its own. However, since inner functions have access to the variables of outer functions, `displayName()` can access the variable name declared in the parent function, `init()`.

	(iii) Scoping with let and const
		
		(a) Traditionally (before ES6), JavaScript only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes:

			if (Math.random() > 0.5) {
			  	var x = 1;
			} else {
			  	var x = 2;
			}
			console.log(x);

		(b) In ES6, JavaScript introduced the `let` and `const` declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables.

			if (Math.random() > 0.5) {
			  	const x = 1;
			} else {
			  	const x = 2;
			}
			console.log(x); // ReferenceError: x is not defined

			In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later.

33. Regular Expressions

	(i) Regular Expressions (regex or regexp) are sequences of characters that form a search pattern. They are used for pattern matching within strings. Regular expressions provide a concise and flexible means for matching strings of text, such as specific characters, words, or patterns of characters. Here are key concepts and components of regular expressions:

	(ii) Syntax

		let RegExpress = /aeiou/ // <-- this is the syntax for Regular Expressions

		let text = "Vowels in English are aeiou";
		
		text = text.replace(RegExpress, "AEIOU")

		console.log(text) // output: Vowels in English are AEIOU

	(iii) Flags
		
		(a) `g` (`g`lobal): Selects Every Match it finds

			let text = "I was is the Kitchen, and then I went is the Bedroom";
			let RegExpress = /is/g
			
			text = text.replace(RegExpress, "'in'")
			console.log(text) 
			// Output: I was 'in' the Kitchen, and then I went 'in' the Bedroom

		(b) `i` (case `i`nsensitive): selects match even if cases don't match

			let text = "They ARE the same!"
			text = text.replace(/are/gi, "are")
			console.log(text) //Output: They `are` the same

	(iii) Literal Characters: Characters in a regular expression match themselves literally. For example, the regex `abc` would match the string "abc" in a text.

	Advance Pattern Matching:

	(iv) Character classes

		(a) .		any character except newline
		(b) \w\d\s	word, digit, whitespace
		(c) \W\D\S	not word, digit, whitespace
		(d) [abc]	any of a, b, or c
		(e) [^abc]	not a, b, or c
		(f) [a-g]	character between a & g

	(v) Anchors

		(a) ^abc abc$	start / end of the string
		(b) \b\B	word, not-word boundary

	(vi) Escaped characters

		(a) \.\*\\	escaped special characters
		(b) \t\n\r	tab, linefeed, carriage return

	(vii) Groups & Lookaround

		(a) (abc)	capture group
		(b) \1	backreference to group #1
		(c) (?:abc)	non-capturing group
		(d) (?=abc)	positive lookahead
		(e) (?!abc)	negative lookahead

	(viii) Quantifiers & Alternation

		(a) a*a+a?	0 or more, 1 or more, 0 or 1
		(b) a{5}a{2,}	exactly five, two or more
		(c) a{1,3}	between one & three
		(d) a+?a{2,}?	match as few as possible
		(e) ab|cd	match ab or cd

34. How JavaScript Works:

	(i) What is JavaScript?

		(a) JavaScript isa single threaded, non blocking, asynchronous concurrent language
		(b) It has a call stack, an event loop and a callback queue + other APIs
		(c) ‘V8 is the JavaScript runtime which has a call stack and a heap
		(d) The heap is used for memory allocation and the stack holds the execution context
		(e) DOM, setTimeout, XML HttpRequest don’t exist in V8 source code

	(ii) Stack Call

		function greeting(){
			sayHi();
		}
		function sayHi(){
			return "Hi!";
		}

		greeting();

		(a) When executed (visually):

			(I) `greeting()` function will go into Stack to be executed

			-------------
			|			|
			|			|
			|			|
			|			|
			| 			|   <-- greeting()
			-------------
			 	Stack

			-------------
			|			|
			|			|
			|			|
			|			|
			| greeting()|
			-------------
			 	Stack

			(II) `greeting()` function will callback `sayHi()` function so it'll also be added into stack to be executed

			-------------
			|			|
			|			|
			|			|
			|			|	<-- sayHi()
			| greeting()|
			-------------
			 	Stack

			-------------
			|			|
			|			|
			|			|
			|  sayHi()	|
			| greeting()|
			-------------
			 	Stack

			(III) Once `sayHi()` is Executed all of it's local variables will be deleted and it'll be thrown out of the Stack 

			-------------
			|			|
			|			|
			|			|
			|  			|	--> sayHi()
			| greeting()|
			-------------
			 	Stack

			-------------
			|			|
			|			|
			|			|
			|  			|
			| greeting()|
			-------------
			 	Stack

			(IV) `greeting()` will also be thrown out once it's executed completely

			-------------
			|			|
			|			|
			|			|
			|  			|
			| 			|	--> greeting()
			-------------
			 	Stack

			-------------
			|			|
			|			|
			|			|
			|  			|
			| 			|
			-------------
			 	Stack

			(Note: Stack is Where the Code gets Executed in JavaScript)

	(iii) Asynchronous CallBacks
		
		(a) Sometimes the JavaScript code can take a lot of time and this can block the page re render
		(b) JavaScript has asynchronous callbacks for non blocking behaviour
		(c) JavaScript runtime can do only one thing at a tim
		(d) Browser gives us other things which work along with the runtime like Web APIs.
		(e) In node, these are available as C++ APIs

	(iv) Task Queue

		(a) JavaScript can only do one thing at a time 
		(b) The rest are queued to the task queue waiting to be executed
		(c) When we run `setTimeout`, webAPIs will run a Timer and when it end it pushes the provided function to the stack where it can be executed
		(d) Task Queue is like a lobby waiting to be executed in Stack

	(v) Event Loop

		(a) JavaScript has a runtime based on event loop, which is reponsible for executing the code, collecting and processing events, and executing queued sub-tasks
		(b) The event loop pushes the tasks from the tasks queue to stack
		(c) `setTimeout(()=>{}, 0)` in this code the function inside setTimeout will defer until all the tasks have been executed if you simplify want it to run without delay just don't provide it a second argument.

Section: Node.js

34. Terminal

	(i) `node {directory}` runs code for a specific directory in Node.js Environment 

35. Package Managers

	(i) NPM
		
		Official Source: "https://www.npmjs.com"

		(a) npm stands for `Node Package Manager`. It is the default package manager for JavaScript runtime environment Node.js. npm is used for managing and sharing JavaScript libraries and tools, making it easier for developers to work on projects, share code, and manage project dependencies.

			Here are some key aspects of npm:

			(I) Package Management: npm allows developers to install, share, and manage dependencies (libraries and tools) in their Node.js projects. Packages are typically distributed as modules, and npm simplifies the process of finding, installing, and updating these modules.4

			(II) Command-Line Interface: npm is primarily used through the command line. Developers can use various commands like `npm install`, `npm init`, `npm publish`, etc., to perform tasks such as installing dependencies, initializing a new project, and publishing packages.

			(III) Package.json: Each Node.js project that uses `npm` has a `package.json` file. This file contains metadata about the project, such as its name, version, description, and most importantly, the list of dependencies required for the project to run. Developers can use the `npm init` command to create a `package.json` file.

			(IV) Scripts: The scripts section in the package.json file allows developers to define custom scripts that can be executed using `npm run`. This is commonly used for automation tasks and running custom commands related to the project.

				Here are some commonly used npm commands:

				(A) `npm install`: Installs dependencies listed in the package.json file.
				(B) `npm install <package-name>`: Installs a specific package and adds it to the package.json file.
				(C) `npm init`: Creates a package.json file interactively.
				(D) `npm publish`: Publishes a package to the npm registry.
				(E) `npm run <script-name>`: Executes a script defined in the scripts section of package.json
				(F) `npm outdated`: Checks for outdated dependencies.
				(G) `npm update`: Updates packages to their latest versions based on the version constraints specified in package.json.

				Overall, npm is a crucial tool in the JavaScript and Node.js ecosystem, providing a standardized way for developers to manage project dependencies and streamline the development process.

		(b) list of all the NPM Commands

			(I) `npm`: Node.js package manager
			(II) `npm access`: Set access level on published packages
			(III) `npm adduser`: Add a registry user account
			(IV) `npm audit`: Run a security audit
			(V) `npm bugs`: Bugs for a package in a web browser maybe
			(VI) `npm cache`: Manipulates packages cache
			(VII) `npm ci`: Install a project with a clean slate
			(VIII) `npm completion`: Tab completion for npm
			(IX) `npm config`: Manage the npm configuration files
			(X) `npm dedupe`: Reduce duplication
			(XI) `npm deprecate`: Deprecate a version of a package
			(XII) `npm diff`: The registry diff command
			(XIII) `npm dist-tag`: Modify package distribution tags
			(XIV) `npm docs`: Docs for a package in a web browser maybe
			(XV) `npm doctor`: Check your environments
			(XVI) `npm edit`: Edit an installed package
			(XVII) `npm exec`: Run a command from an npm package
			(XVIII) `npm explain`: Explain installed packages
			(XIX) `npm explore`: Browse an installed package
			(XX) `npm find-dupes`: Find duplication in the package tree
			(XXI) `npm fund`: Retrieve funding information
			(XXI) `npm help`: Search npm help documentation
			(XXII) `npm help-search`: Get help on npm
			(XXIII) `npm hook`: Manage registry hooks
			(XXIV) `npm init`: Create a package.json file
			(XXV) `npm install`: Install a package
			(XXVI) `npm install-ci-test`: Install a project with a clean slate and run tests
			(XXVII) `npm install-test`: Install package(s) and run tests
			(XXVIII) `npm link`: Symlink a package folder
			(XXIX) `npm login`: Login to a registry user account
			(XXX) `npm logout`: Log out of the registry
			(XXXI) `npm ls`: List installed packages
			(XXXII) `npm org`: Manage orgs
			(XXXIII) `npm outdated`: Check for outdated packages
			(XXXIV) `npm owner`: Manage package owners
			(XXXV) `npm pack`: Create a tarball from a package
			(XXXVI) `npm ping`: Ping npm registry
			(XXXVII) `npm pkg`: Manages your package.json
			(XXXVIII) `npm prefix`: Display prefix
			(XXXIX) `npm profile`: Change settings on your registry profile
			(XL) `npm prune`: Remove extraneous packages
			(XLI) `npm publish`: Publish a package
			(XLII) `npm query`: Retrieve a filtered list of packages
			(XLIII) `npm rebuild`: Rebuild a package
			(XLIV) `npm repo`: Open package repository page in the browser
			(XLV) `npm restart`: Restart a package
			(XLVI) `npm root`: Display npm root
			(XLVII) `npm run-script`: Run arbitrary package scripts
			(XLVIII) `npm sbom`: Generate a Software Bill of Materials (SBOM)
			(XLIX) `npm search`: Search for packages
			(L) `npm shrinkwrap`: Lock down dependency versions for publication
			(LI) `npm star`: Mark your favorite packages
			(LII) `npm stars`: View packages marked as favorites
			(LIII) `npm start`: Start a package
			(LIV) `npm stop`: Stop a package
			(LV) `npm team`: Manage organization teams and team memberships
			(LVI) `npm test`: Test a package
			(LVII) `npm token`: Manage your authentication tokens
			(LVIII) `npm uninstall`: Remove a package
			(LIX) `npm unpublish`: Remove a package from the registry
			(L) `npm unstar`: Remove an item from your favorite packages
			(LI) `npm update`: Update a package
			(LII) `npm version`: Bump a package version
			(LIII) `npm view`: View registry info
			(LIV) `npm whoami`: Display npm username
			(LV) `npx`: Run a command from an npm package

36. Modules Types

	(i) there are a number of JavaScript libraries and frameworks that enable module usage (for example, other `CommonJS` and AMD-based module systems like `RequireJS`, and more recently Webpack and Babel).

	(ii) Basic example structure
		
		(a) In the following example (see basic-modules) we have a file structure as follows:

			index.html
			main.js
			modules/
			    canvas.js
			    square.js

		(b) The modules directory's two modules are described below:

			(I) canvas.js — contains functions related to setting up the canvas:

				(a) `create()`: creates a canvas with a specified width and height inside a wrapper <div> with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID.
				(b) `createReportList()`: creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID.

			(I) square.js — contains:

				(a) `name`: a constant containing the string 'square'.
				(b) `draw()`: draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color.
				(c) `reportArea()`: writes a square's area to a specific report list, given its length.
				(d) `reportPerimeter()`: writes a square's perimeter to a specific report list, given its length.

	(iii) Aside — `.mjs` versus `.js` we've used `.js` extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are:

		(a) It is good for clarity, i.e. it makes it clear which files are modules, and which are regular JavaScript.
		(b) It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel.

		(c) However, we decided to keep using `.js`, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as `text/javascript`. If you don't, you'll get a strict MIME type checking error along the lines of "The server responded with a non-JavaScript MIME type" and the browser won't run your JavaScript. Most servers already set the correct type for `.js` files, but not yet for `.mjs` files. Servers that already serve `.mjs` files correctly include GitHub Pages and http-server for Node.js.

		(d) If you really value the clarity of using `.mjs` for modules versus using `.js` for "normal" JavaScript files, but don't want to run into the problem described above, you could always use `.mjs` during development and convert them to .js during your build step.

	(iv) Exporting module features

		(a) ES6 Method is the easiest way to use it, using `export` & `default` keyword:

			export const name = "square";

			export function draw(ctx, length, x, y, color) {
			  	ctx.fillStyle = color;
				ctx.fillRect(x, y, length, length);

				return { length, x, y, color };
			}

			(I) You can export `functions`, `var`, `let`, `const`, and `classes`. They need to be top-level items; you can't use export inside a function, for example.
			(II) A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example:

				export { name, draw, reportArea, reportPerimeter };

			(III) `default` keyword let's you export `functions`, `var`, `let`, `const`, and `classes` retrieve it without destructuring

				export default name;

		(b) in Common.JS, Assign Values to `Module.exports` to export them!.
			
			for example:-

				const sayHello = (name)=>{
					console.log(`hello ${name}!`)
				}
				const sayGoodMorning = (name)=>{
					console.log(`good morning ${name}!`)
				}
				WebAssembly.Module.exports = {sayHello, sayGoodMorning};

			This above code is same as:

				export const sayHello = (name)=>{
					console.log(`hello ${name}!`)
				}
				export const sayGoodMorning = (name)=>{
					console.log(`good morning ${name}!`)
				}
		
	(v) Importing module features into your script
		
		(a) ES6 Method is (Again) the easiest way to use it, using `import` and `from` keyword:

			import { name, draw, reportArea, reportPerimeter } from "./modules/square.js";

			// If you've used `default` keyword

			import name {draw, reportArea, reportPerimeter } from "./modules/square.js";
			
			(I) use the `import` statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword `from`, followed by the module specifier.

			(II) The module specifier provides a string that the JavaScript environment can resolve to a path to the module file. In a browser, this could be a path relative to the site root, which for our basic-modules example would be `/js-examples/module-examples/basic-modules`. However, here we are instead using the dot (`.`) syntax to mean "the current location", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy.  for example:

				`C:/Users/Admin/Documents/project/examples/modules/square.js` becomes `./modules/square.js`

		(b) Common.JS Module import uses `require()`function, which allows you to load and used external modules (pieces of code) in a Node.js application

			(I) Loading Modules: When you use `require()`, you provide the path to the module you want to load. This can be a relative path to a local file or the name of a module installed via npm.

				(A) Example for loading a local file:

					const myModule = require('./myModule');

				(B) Example for loading an npm module:

					const express = require('express');
			
			(II) Path Resolution:

				(A) If the path provided to `require()` is a local file, Node.js resolves the path based on the current file's location. Relative paths (`./`, `../`) are resolved relative to the current file.
				(B) If the path is a module name (like 'express'), Node.js looks for the module in the `node_modules` folder in the current directory and its parent directories.

	(vi) Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines:

		const myCanvas = create("myCanvas", document.body, 480, 320);
		const reportList = createReportList(myCanvas.id);

		const square1 = draw(myCanvas.ctx, 50, 50, 100, "blue");
		reportArea(square1.length, reportList);
		reportPerimeter(square1.length, reportList);

The Above Section has Ended on 12 November 2023

37. Built in Modules

	(i) `HTTP Module`:

		(a) http module in Node.js is a core module that provides functionality for creating HTTP servers and making HTTP requests. This module allows you to build both server-side and client-side components for handling HTTP communication.

		(b) HTTP Server with http Module:

			(Note: It's recommended to make a server with `express.js`)

			(I) Creating an HTTP Server:

				(A) You can create an HTTP server using the `http.createServer()` method. This method takes a callback function that is executed for each incoming HTTP request.

				const http = require('http');
				const server = http.createServer((req, res) => {
				    // Request handling logic here
				    res.writeHead(200, { 'Content-Type': 'text/plain' });
				    res.end('Hello, World!\n');
				});
				const port = 3000;
				server.listen(port, () => {
				    console.log(`Server listening on port ${port}`);
				});

				(B) Handling Incoming Requests: The callback function passed to `createServer` takes two parameters: `req` (the request object) and `res` (the response object). You handle incoming requests and send responses within this function.

		(c) HTTP Client with http Module:
			
			(I) Making HTTP Requests: 
				
				(A) The http module can be used to make HTTP requests. The `http.request()` method is commonly used for this purpose.

					const http = require('http');

					const options = {
					    hostname: 'www.example.com',
					    port: 80,
					    path: '/',
					    method: 'GET',
					};

					const req = http.request(options, (res) => {
					    let data = '';

					    // A chunk of data has been received.
					    res.on('data', (chunk) => {
					        data += chunk;
					    });

					    // The whole response has been received.
					    res.on('end', () => {
					        console.log(data);
					    });
					});

					req.end(); // Important: Close the request stream.

				(B) Handling Responses: Similar to the server side, you handle responses by listening for events on the response object (`res`).

		Key Concepts:
		
		(d) Request Object (req): Represents the HTTP request and contains information about the incoming request, such as headers and URL.
		
		(e) Response Object (res): Represents the HTTP response that will be sent back to the client. You use methods like `res.writeHead()` and `res.end()` to send the response.
		
		(f) Event Emitters: Both the `req` and `res` objects are event emitters. You can listen for events like 'data', 'end', and others to handle the flow of data.
		
		(g) Options Object: When making HTTP requests, an options object is often used to specify details such as the hostname, port, path, and request method.
		
		(h) Status Codes: HTTP status codes (e.g., 200 for OK, 404 for Not Found) are used in the `res.writeHead` method to communicate the status of the response.

	(ii) `File System Module`:
	
		(a)  The File System module in Node.js, often referred to as the `fs` module, provides an interface for interacting with the file system. It allows you to perform various file-related operations, such as reading from and writing to files, creating and deleting directories, and more.
			
		(b) Callback API
			
			(I) `fs.access(path[, mode], callback)`: Checks the accessibility of a file or directory.
			   	
			   	fs.access('/path/to/file.txt', fs.constants.F_OK, (err) => {
			       	if (err) {
			           	console.error('File is not accessible');
			       	} else {
			           	console.log('File is accessible');
			       	}
			   	});
				
			(II) `fs.appendFile(path, data[, options], callback)`: Appends data to a file, creating the file if it does not exist.
			   	
			   	fs.appendFile('/path/to/file.txt', 'Hello, World!', (err) => {
			       	if (err) {
			           	console.error('Error appending data to the file');
			       	} else {
			           	console.log('Data has been appended to the file');
			       	}
			   	});
				
			(III) `fs.chmod(path, mode, callback)`: Changes the permissions of a file or directory.
			   	
			   	fs.chmod('/path/to/file.txt', 0o755, (err) => {
			       	if (err) {
			           	console.error('Error changing file permissions');
			       	} else {
			           	console.log('File permissions have been changed');
			       	}
			   	});
				
			(IV) `fs.chown(path, uid, gid, callback)`: Changes the ownership of a file or directory.
			   	
			   	fs.chown('/path/to/file.txt', 1000, 1000, (err) => {
			       	if (err) {
			           	console.error('Error changing file ownership');
			       	} else {
			           	console.log('File ownership has been changed');
			       	}
			   	});
				
			(V) `fs.close(fd[, callback])`: Closes an open file descriptor.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.close(fd, (err) => {
			       	if (err) {
			           	console.error('Error closing file');
			       	} else {
			           	console.log('File has been closed');
			       	}
			   	});
				
			(VI) `fs.copyFile(src, dest[, mode], callback)`: Copies the contents of a file to another file.
			   	
			   	fs.copyFile('/path/to/source.txt', '/path/to/destination.txt', (err) => {
			       	if (err) {
			           	console.error('Error copying file');
			       	} else {
			           	console.log('File has been copied successfully');
			       	}
			   	});
				
			(VII) `fs.cp(src, dest[, options], callback)`: Copies a file or directory to another location.
			   	
			   	fs.cp('/path/to/source', '/path/to/destination', { recursive: true }, (err) => {
			       	if (err) {
			           	console.error('Error copying file or directory');
			       	} else {
			           	console.log('File or directory has been copied successfully');
			       	}
			   	});
				
			(VIII) `fs.createReadStream(path[, options])`: Creates a readable stream from a file.
			   	
			   	const readStream = fs.createReadStream('/path/to/file.txt', { encoding: 'utf8' });
			   	readStream.on('data', (chunk) => console.log(chunk));
				
			(IX) `fs.createWriteStream(path[, options])`: Creates a writable stream to a file.
			   	
			   	const writeStream = fs.createWriteStream('/path/to/output.txt', { encoding: 'utf8' });
			   	writeStream.write('Hello, World!');
				
			(X) `fs.exists(path, callback)`: Checks if a file or directory exists. *Note: Deprecated in recent versions of Node.js.*
			    	
			    	fs.exists('/path/to/file.txt', (exists) => {
			        	if (exists) {
			            	console.log('File exists');
			        	} else {
			            	console.log('File does not exist');
			        	}
			    	});

			(XI) `fs.fchmod(fd, mode, callback)`: Changes the permissions of a file referenced by the file descriptor.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.fchmod(fd, 0o755, (err) => {
			       	if (err) {
			           	console.error('Error changing file permissions');
			       	} else {
			           	console.log('File permissions have been changed');
			           	fs.closeSync(fd);
			       	}
			   	});
			   	
			(XII) `fs.fchown(fd, uid, gid, callback)`: Changes the ownership of a file referenced by the file descriptor.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.fchown(fd, 1000, 1000, (err) => {
			       	if (err) {
			           	console.error('Error changing file ownership');
			       	} else {
			           	console.log('File ownership has been changed');
			           	fs.closeSync(fd);
			       	}
			   	});
			   	
			(XIII) `fs.fdatasync(fd, callback)`: Synchronizes changes made to a file with the disk.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	fs.writeSync(fd, 'Hello, World!');
			   	fs.fdatasync(fd, (err) => {
			       	if (err) {
			           	console.error('Error synchronizing file data');
			       	} else {
			           	console.log('File data has been synchronized');
			           	fs.closeSync(fd);
			       	}
			   	});
			   	
			(XIV) `fs.fstat(fd[, options], callback)`: Gets the status of a file referenced by the file descriptor.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.fstat(fd, (err, stats) => {
			       	if (err) {
			           	console.error('Error getting file status');
			       	} else {
			           	console.log('File status:', stats);
			           	fs.closeSync(fd);
			       	}
			   	});
						   	
			(XV) `fs.fsync(fd, callback)`: Flushes the changes made to a file to the disk.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	fs.writeSync(fd, 'Hello, World!');
			   	fs.fsync(fd, (err) => {
			       	if (err) {
			           	console.error('Error flushing changes to the file');
			       	} else {
			           	console.log('Changes have been flushed to the file');
			           	fs.closeSync(fd);
			       	}
			   	});
			   	
			(XVI) `fs.ftruncate(fd[, len], callback)`: Truncates a file referenced by the file descriptor to a specified length.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	fs.writeSync(fd, 'Hello, World!');
			   	fs.ftruncate(fd, 5, (err) => {
			       	if (err) {
			           	console.error('Error truncating the file');
			       	} else {
			           	console.log('File has been truncated');
			           	fs.closeSync(fd);
			       	}
			   	});
			   	
			(XVII) `fs.futimes(fd, atime, mtime, callback)`: Changes the access and modification times of a file referenced by the file descriptor.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	const now = new Date();
			   	fs.futimes(fd, now, now, (err) => {
			       	if (err) {
			           	console.error('Error updating file times');
			       	} else {
			           	console.log('File times have been updated');
			           	fs.closeSync(fd);
			       	}
			   	});
			   	
			(XVIII) `fs.lchmod(path, mode, callback)`: Changes the permissions of a symbolic link.
			   	
			   	fs.lchmod('/path/to/symlink.txt', 0o755, (err) => {
			       	if (err) {
			           	console.error('Error changing symbolic link permissions');
			       	} else {
			           	console.log('Symbolic link permissions have been changed');
			       	}
			   	});
			   	
			(XIX) `fs.lchown(path, uid, gid, callback)`: Changes the ownership of a symbolic link.
			   	
			   	fs.lchown('/path/to/symlink.txt', 1000, 1000, (err) => {
			       	if (err) {
			           	console.error('Error changing symbolic link ownership');
			       	} else {
			           	console.log('Symbolic link ownership has been changed');
			       	}
			   	});
			   	
			(XX) `fs.lutimes(path, atime, mtime, callback)`: Changes the access and modification times of a file or directory.
			   	
			   	const now = new Date();
			   	fs.lutimes('/path/to/file.txt', now, now, (err) => {
			       	if (err) {
			           	console.error('Error updating file times');
			       	} else {
			           	console.log('File times have been updated');
			       	}
			   	});
			   	
			(XXI) `fs.link(existingPath, newPath, callback)`: Creates a new hard link to an existing file.  
			   	
			   	fs.link('/path/to/existing/file.txt', '/path/to/new/link.txt', (err) => {
			       	if (err) throw err;
			       	console.log('Hard link created successfully');
			   	});
				
			(XXII) `fs.lstat(path[, options], callback)`: Retrieves statistics of the file or symbolic link.  
			   	
			   	fs.lstat('/path/to/file_or_link', (err, stats) => {
			       	if (err) throw err;
			       	console.log('Stats:', stats);
			   	});
				
			(XXIII) `fs.mkdir(path[, options], callback)`: Creates a new directory.  
			   	
			   	fs.mkdir('/new/directory', (err) => {
			       	if (err) throw err;
			       	console.log('Directory created successfully');
			   	});
				
			(XXIV) `fs.mkdtemp(prefix[, options], callback)`: Creates a temporary directory.  
			   	
			   	fs.mkdtemp('temp-', (err, folder) => {
			       	if (err) throw err;
			       	console.log('Temporary directory created:', folder);
			   	});
				
			(XXV) `fs.open(path[, flags[, mode]], callback)`: Opens a file and returns a file descriptor.  
			   	
			   	fs.open('/path/to/file.txt', 'r', (err, fd) => {
			       	if (err) throw err;
			       	console.log('File opened with file descriptor:', fd);
			       	fs.close(fd, (err) => {
			           	if (err) throw err;
			       	});
			   	});
				
			(XXVI) `fs.openAsBlob(path[, options])`: This method seems to be non-standard or not part of the typical Node.js `fs` module as of my last update. Please check the latest Node.js documentation for this.
				
			(XXVII) `fs.opendir(path[, options], callback)`: Opens a directory for reading.  
			   	
			   	fs.opendir('/path/to/directory', (err, dir) => {
			       	if (err) throw err;
			       	console.log('Directory opened:', dir);
			   	});
				
			(XXVIII) `fs.read(fd, buffer, offset, length, position, callback)`: Reads data from a file descriptor into a buffer.  
			   	
			   	const buffer = Buffer.alloc(1024);
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.read(fd, buffer, 0, buffer.length, 0, (err, bytesRead, buffer) => {
			       	if (err) throw err;
			       	console.log('Bytes read:', bytesRead);
			       	console.log('Data:', buffer.toString());
			       	fs.closeSync(fd);
			   	});
				
			(XXIX) `fs.read(fd[, options], callback)`: Reads data from a file descriptor.  
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.read(fd, { length: 1024 }, (err, bytesRead, buffer) => {
			       	if (err) throw err;
			       	console.log('Bytes read:', bytesRead);
			       	console.log('Data:', buffer.toString());
			       	fs.closeSync(fd);
			   	});
				
			(XXX) `fs.read(fd, buffer[, options], callback)`: Reads data from a file descriptor into a buffer with additional options.  
			   	
			   	const buffer = Buffer.alloc(1024);
			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	fs.read(fd, buffer, { length: buffer.length, position: 0 }, (err, bytesRead, buffer) => {
			       	if (err) throw err;
			       	console.log('Bytes read:', bytesRead);
			       	console.log('Data:', buffer.toString());
			       	fs.closeSync(fd);
			   	});

			(XXXI) `fs.readdir(path[, options], callback)`: Reads the contents of a directory.

			   	fs.readdir('/path/to/directory', (err, files) => {
			       	if (err) throw err;
			       	console.log('Files in directory:', files);
			   	});

			(XXXII) `fs.readFile(path[, options], callback)`: Reads the entire contents of a file.

			   	fs.readFile('/path/to/file.txt', 'utf8', (err, data) => {
			       	if (err) throw err;
			       	console.log('File content:', data);
			   	});

			(XXXIII) `fs.readlink(path[, options], callback)`: Reads the symbolic link's value.

			   	fs.readlink('/path/to/symlink', (err, linkString) => {
			       	if (err) throw err;
			       	console.log('Symbolic link points to:', linkString);
			   	});

			(XXXIV) `fs.readv(fd, buffers[, position], callback)`: Reads data from a file descriptor into an ary of buffers.  

			   	const fd = fs.openSync('/path/to/file.txt', 'r');
			   	const buffers = [Buffer.alloc(16), Buffer.alloc(16)];
			   	fs.readv(fd, buffers, 0, (err, bytesRead) => {
			       	if (err) throw err;
			       	console.log('Bytes read:', bytesRead);
			       	console.log('Data:', buffers[0].toString(), buffers[1].toString());
			       	fs.closeSync(fd);
			   	});

			(XXXV) `fs.realpath(path[, options], callback)`: Returns the resolved absolute path.

			   	fs.realpath('/path/to/link', (err, resolvedPath) => {
			       	if (err) throw err;
			       	console.log('Resolved path:', resolvedPath);
			   	});

			(XXXVI) `fs.realpath.native(path[, options], callback)`: Same as `fs.realpath` but using the native metd in the file system.  

			   	fs.realpath.native('/path/to/link', (err, resolvedPath) => {
			       	if (err) throw err;
			       	console.log('Native resolved path:', resolvedPath);
			   	});

			(XXXVII) `fs.rename(oldPath, newPath, callback)`: Renames a file or directory.

			   	fs.rename('/old/path/file.txt', '/new/path/file.txt', (err) => {
			       	if (err) throw err;
			       	console.log('File renamed successfully');
			   	});

			(XXXVIII) `fs.rmdir(path[, options], callback)`: Removes a directory.

			   	fs.rmdir('/path/to/directory', (err) => {
			       	if (err) throw err;
			       	console.log('Directory removed successfully');
			   	});

			(XXXIX) `fs.rm(path[, options], callback)`: Removes files or directories.

			   	fs.rm('/path/to/file_or_directory', { recursive: true }, (err) => {
			       	if (err) throw err;
			       	console.log('Removed successfully');
			   	});

			(XL) `fs.stat(path[, options], callback)`: Retrieves statistics of the file.

			   	fs.stat('/path/to/file.txt', (err, stats) => {
			       	if (err) throw err;
			       	console.log('File stats:', stats);
			   	});
    		
			(XLI) `fs.statfs(path[, options], callback)`: Provides statistics about a file system.
			   	
			   	fs.statfs('/path/to/file', (err, stats) => {
			       	if (err) throw err;
			       	console.log('File system stats:', stats);
			   	});

			(XLII) `fs.symlink(target, path[, type], callback)`: Creates a symbolic link to a file.
			   	
			   	fs.symlink('/path/to/original', '/path/to/link', 'file', (err) => {
			       	if (err) throw err;
			       	console.log('Symlink created successfully');
			   	});

			(XLIII) `fs.truncate(path[, len], callback)`: Truncates a file to a specified length.
			   	
			   	fs.truncate('/path/to/file.txt', 10, (err) => {
			       	if (err) throw err;
			       	console.log('File truncated successfully');
			   	});

			(XLIV) `fs.unlink(path, callback)`: Removes a file or symbolic link.
			   	
			   	fs.unlink('/path/to/file.txt', (err) => {
			       	if (err) throw err;
			       	console.log('File removed successfully');
			   	});

			(XLV) `fs.unwatchFile(filename[, listener])`: Stops watching for changes on a file.
			   	
			   	fs.unwatchFile('/path/to/file.txt');
			   	console.log('Stopped watching file');

			(XLVI) `fs.utimes(path, atime, mtime, callback)`: Changes the file timestamps of a file.
			   	
			   	fs.utimes('/path/to/file.txt', new Date(), new Date(), (err) => {
			       	if (err) throw err;
			       	console.log('File timestamps updated successfully');
			   	});

			(XLVII) `fs.watch(filename[, options][, listener])`: Watches for changes on a file or directory.
			   	
			   	fs.watch('/path/to/file_or_dir', (eventType, filename) => {
			       	console.log(`Event type: ${eventType}; File: ${filename}`);
			   	});

			(XLVIII) `fs.watchFile(filename[, options], listener)`: Watches for changes on a file.
			   	
			   	fs.watchFile('/path/to/file.txt', (curr, prev) => {
			       	console.log('File changed');
			   	});

			(XLIX) `fs.write(fd, buffer, offset[, length[, position]], callback)`: Writes data to a file.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	const buffer = Buffer.from('Hello World');
			   	fs.write(fd, buffer, 0, buffer.length, null, (err, written) => {
			       	if (err) throw err;
			       	console.log(`Bytes written: ${written}`);
			       	fs.closeSync(fd);
			   	});

			(L) `fs.write(fd, buffer[, options], callback)`: Writes data to a file, similar to the previous but with options.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	const buffer = Buffer.from('Hello World');
			   	fs.write(fd, buffer, { encoding: 'utf8' }, (err, written) => {
			       	if (err) throw err;
			       	console.log(`Bytes written: ${written}`);
			       	fs.closeSync(fd);
			   	});

    		It seems like there's a slight discrepancy in the numbering. Let's correct that and provide explanations and examples for the specified `fs` methods:

			(LI) `fs.write(fd, string[, position[, encoding]], callback)`: Writes a string to a file.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	fs.write(fd, 'Hello World', null, 'utf8', (err, written) => {
			       	if (err) throw err;
			       	console.log(`Bytes written: ${written}`);
			       	fs.closeSync(fd);
			   	});
			   	```

			(LII) `fs.writeFile(file, data[, options], callback)`: Writes data to a file, replacing the file if it already exists.
			   	
			   	fs.writeFile('/path/to/file.txt', 'Hello World', { encoding: 'utf8' }, (err) => {
			       	if (err) throw err;
			       	console.log('File written successfully');
			   	});
			   	```

			(LIII) `fs.writev(fd, buffers[, position], callback)`: Writes multiple buffers to a file using a single system call.
			   	
			   	const fd = fs.openSync('/path/to/file.txt', 'w');
			   	const buffers = [Buffer.from('Hello'), Buffer.from(' World')];
			   	fs.writev(fd, buffers, 0, (err, written) => {
			       	if (err) throw err;
			       	console.log(`Bytes written: ${written}`);
			       	fs.closeSync(fd);
			   	});

		(c) Synchronous API (Not Recommended)

			(I) Methods of Synchronous version of fs methods ends with `Sync` and doesn't takes a callback and instead returns the value and errors needs to be handled with a try..catch
			
    		(II) Example:-

				try{
					const files = fs.readdirSync('./', 'utf8') 
					// ...
				} catch (error){
					console.log(error)
				}

		(d) Promises API (Recommended)

			(I) Promises API version of fs modules are the same as it's Synchronous API but it's Asynchronous meaning it returns a Promise meaning it has be awaited.
			(II) Unlike Callback and Synchronous API, Promises API have the same names for Methods as Callback API, so to avoid name Collisions Promises API have their own Object inside fs module called `promises`

			(III) Example:-

				import fs from 'fs'; // ES6
				const fs = require('fs'); // Common JS

				// Using Async/Await
				(async () => {
					const files = await fs.promises.readdir('./', 'utf8')
					// ...
				})()

				// Using Then..Catch
				
				fs.promises.readdir('./', 'utf8')
					.then(files=>{
						//...
					}).catch(error=>console.log("Error"))

		(e) Objects
			
		    (I) Object: `fs.Dir`

		        (A) dir.close()
		        (B) dir.close(callback)
		        (C) dir.closeSync()
		        (D) dir.path
		        (E) dir.read()
		        (F) dir.read(callback)
		        (G) dir.readSync()
		        (H) dir[Symbol.asyncIterator]()

		    (II) Object: `fs.Dirent`

		        (A) dirent.isBlockDevice()
		        (B) dirent.isCharacterDevice()
		        (C) dirent.isDirectory()
		        (D) dirent.isFIFO()
		        (E) dirent.isFile()
		        (F) dirent.isSocket()
		        (G) dirent.isSymbolicLink()
		        (H) dirent.name
		        (I) dirent.parentPath
		        (J) dirent.path

		    (III) Object: `fs.FSWatcher`

		        (A) Event: 'change'
		        (B) Event: 'close'
		        (C) Event: 'error'
		        (D) watcher.close()
		        (E) watcher.ref()
		        (F) watcher.unref()

		    (IV) Object: `fs.StatWatcher`

		        (A) watcher.ref()
		        (B) watcher.unref()

		    (V) Object: `fs.ReadStream`

		        (A) Event: 'close'
		        (B) Event: 'open'
		        (C) Event: 'ready'
		        (D) readStream.bytesRead
		        (E) readStream.path
		        (F) readStream.pending

		    (VI) Object: `fs.Stats`

		        (A) stats.isBlockDevice()
		        (B) stats.isCharacterDevice()
		        (C) stats.isDirectory()
		        (D) stats.isFIFO()
		        (E) stats.isFile()
		        (F) stats.isSocket()
		        (G) stats.isSymbolicLink()
		        (H) stats.dev
		        (I) stats.ino
		        (J) stats.mode
		        (K) stats.nlink
		        (L) stats.uid
		        (M) stats.gid
		        (N) stats.rdev
		        (O) stats.size
		        (P) stats.blksize
		        (Q) stats.blocks
		        (R) stats.atimeMs
		        (S) stats.mtimeMs
		        (T) stats.ctimeMs
		        (U) stats.birthtimeMs
		        (V) stats.atimeNs
		        (W) stats.mtimeNs
		        (X) stats.ctimeNs
		        (Y) stats.birthtimeNs
		        (Z) stats.atime
		        (ZA) stats.mtime
		        (ZB) stats.ctime
		        (ZC) stats.birthtime
		        (ZD) Stat time values

		    (VII) Object: `fs.StatFs`

		        (A) statfs.bavail
		        (B) statfs.bfree
		        (C) statfs.blocks
		        (D) statfs.bsize
		        (E) statfs.ffree
		        (F) statfs.files
		        (G) statfs.type

		    (VIII) Object: `fs.WriteStream`

		        (A) Event: 'close'
		        (B) Event: 'open'
		        (C) Event: 'ready'
		        (D) writeStream.bytesWritten
		        (E) writeStream.close([callback])
		        (F) writeStream.path
		        (G) writeStream.pending
		    
			(IX) fs.constants

		        (A) FS constants

		            I. File access constants
		            II. File copy constants
		            III. File open constants
		            IV. File type constants
		            V. File mode constants

	(iii) `Path Module`:
	
		(a) The path module helps in creating and manipulating file paths in a way that is platform-agnostic, meaning it works consistently across different operating systems (Windows, Linux, macOS, etc.).

		Here are some common functions provided by the path module:

		(b) `path.join([...paths])`: This method joins all the given path segments together. The resulting path is normalized, and any '..' or '.' segments are resolved.

			const path = require('path');

			const fullPath = path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
			console.log(fullPath);
			// Output on Unix-like systems: '/foo/bar/baz/asdf'
			// Output on Windows: '\foo\bar\baz\asdf'

		(c) `path.resolve([...paths])`: Resolves the specified paths into an absolute path. It behaves similarly to `path.join()`, but it also resolves any relative paths based on the current working directory.

			const fullPath = path.resolve('path', 'to', 'file.txt');
			console.log(fullPath);
			// Output on Unix-like systems: '/current/working/directory/path/to/file.txt'
			// Output on Windows: 'C:\current\working\directory\path\to\file.txt'

		(d) `path.basename(path[, ext])`: Returns the last portion of a path, similar to the Unix `basename` command. Optionally, you can provide an extension, and the base name will be without that extension.

			const fileName = path.basename('/path/to/file.txt');
			console.log(fileName); // Output: 'file.txt'
			
			const baseNameWithoutExt = path.basename('/path/to/file.txt', '.txt');
			console.log(baseNameWithoutExt); // Output: 'file'

		(e) `path.dirname(path)`: Returns the directory name of a path.

			const dirName = path.dirname('/path/to/file.txt');
			console.log(dirName);
			// Output on Unix-like systems: '/path/to'
			// Output on Windows: '\path\to'

		(f) `path.extname(path)`: Returns the extension of the path, including the period (`.`).

			const extension = path.extname('/path/to/file.txt');
			console.log(extension); // Output: '.txt'

		(g) `path.normalize(path)`: Normalizes the given path, resolving '..' and '.' segments. It simplifies the path and makes it more consistent.

			const normalizedPath = path.normalize('/foo/bar//baz/asdf/quux/..');
			console.log(normalizedPath);
			// Output on Unix-like systems: '/foo/bar/baz/asdf'
			// Output on Windows: '\foo\bar\baz\asdf'

		(h) `path.isAbsolute(path)`: Determines if the given path is an absolute path.

			console.log(path.isAbsolute('/foo/bar')); // Output: true
			console.log(path.isAbsolute('foo/bar'));  // Output: false

		(i) `path.relative(from, to)`: Returns the relative path from the from path to the to path.

			const relativePath = path.relative('/data', '/data/file.txt');
			console.log(relativePath); // Output: 'file.txt'

		(j) `path.parse(pathString)`: Returns an object from a path string, providing information about the path.

			const pathInfo = path.parse('/path/to/file.txt');
			console.log(pathInfo);
			/* Output:
			{
			  	root: '/',
			  	dir: '/path/to',
			  	base: 'file.txt',
			  	ext: '.txt',
			  	name: 'file'
			}
			*/

		(k) `path.sep` and `path.delimiter`: These properties provide the platform-specific path segment separator (`/` on Unix-like systems, `\` on Windows) and the platform-specific path delimiter for PATH environment variable (: on Unix-like systems, ; on Windows), respectively.

			console.log(path.sep);       // Output: '/' on Unix-like systems, '\' on Windows
			console.log(path.delimiter); // Output: ':' on Unix-like systems, ';' on Windows
		
		Variables:
		
		(l) `__dirname` represents the current directory that the file is stored in

			console.log(path.join(__dirname))
			// C:/users/documents/project

		(m) `__filename` represents the current file

			console.log(path.join(__filename))
			// index.js

	(iv) `Events Module`:
	
		(a) `events`: Implements the EventEmitter pattern, allowing objects to emit and listen for events.

	(v) `OS Module`:
	
		(a) `os.EOL`:

			(I) Returns the end-of-line marker used by the operating system.
			This is a string value, typically '\n' on POSIX systems and '\r\n' on Windows.

		(b) `os.availableParallelism()`:

			(I) This function does not exist in the Node.js os module. Perhaps you meant something else?

		(c) `os.arch()`:

			(I) Returns a string identifying the CPU architecture.
			Possible values include 'x64', 'arm', 'ia32', etc.

		(d) `os.constants`:

			(I) An object containing various operating system-specific constants.
			These constants include error codes, signals, priority values, and more.

		(e) `os.cpus()`:

			(I) Returns an array of objects containing information about each CPU/core.
			Each object typically includes details such as model, speed, and times (user, nice, sys, idle, irq).

		(f) `os.devNull`:

			(I) A string constant representing the path to the null device on the system.
			This device is used to discard data written to it.

		(g) `os.endianness()`:

			(I) Returns the endianness of the CPU. Either 'BE' for big-endian or 'LE' for little-endian.

		(h) `os.freemem()`:

			(I) Returns the amount of free system memory in bytes.

		(i) `os.getPriority([pid])`:

			(I) Returns the priority of the process identified by pid (default is the current process).
			The priority is an integer value representing the scheduling priority of the process.

		(j) `os.homedir()`:

			(I) Returns the path to the current user's home directory.
		        This is typically the user's home directory, such as /home/user on Unix-like systems or C:\Users\user on Windows.

		(k) `os.hostname()`:

		    (I) Returns the hostname of the operating system.

		(l) `os.loadavg()`:

		    (I) Returns an array containing the average system load over the last 1, 5, and 15 minutes.
		    (II) Load average is a measure of the amount of computational work that a system is performing.

		(m) `os.machine()`:

		    (I) This function does not exist in the Node.js `os` module. Perhaps you meant something else?

		(n) `os.networkInterfaces()`:

		    (I) Returns an object containing information about the network interfaces available on the system.
		    (II) Each key of the object corresponds to a network interface name, and the value is an array of network interface objects.

		(o) `os.platform()`:

		    (I) Returns a string identifying the operating system platform.
		    (II) Possible values include 'darwin', 'win32', 'linux', etc.

		(p) `os.release()`:

		    (I) Returns a string identifying the operating system release.
		    (II) The format of the string varies depending on the operating system.

		(q) `os.setPriority([pid, ]priority)`:

		    (I) Sets the priority of the process identified by `pid` (default is the current process) to the specified `priority`.
		    (II) The `priority` parameter is an integer value representing the scheduling priority of the process.

		(r) `os.tmpdir()`:

		    (I) Returns the directory for temporary files.
		    (II) This is typically a string representing the operating system's default directory for temporary files.

		(s) `os.totalmem()`:

		    (I) Returns the total amount of system memory (RAM) in bytes.

		(t) `os.type()`:

		    (I) Returns a string identifying the operating system type.
		    (II) Possible values include 'Linux', 'Windows_NT', 'Darwin', etc.

		(u) `os.uptime()`:

		    (I) Returns the system uptime in seconds.
		    (II) This is the amount of time the system has been running since the last boot.

		(v) `os.userInfo([options])`:

		    (I) Returns information about the current user.
		    (II) The returned object contains details such as username, uid, gid, shell, home directory, etc.

		(w) `os.version()`:

		    (I) Returns a string representing the operating system version.

	(vi) `Query String Module`:
	
		(a) `querystring`: Provides methods for parsing and formatting URL query strings.

	(vii) `URL Module`:
	
		(a) `url`: Parses URLs and provides utilities for working with URLs.

	(viii) `Net Module`:
	
		(a) `net`: Provides functionality for creating TCP servers and clients.

	(ix) `Stream Module`:
	
		(a) `stream`: Implements the stream interface for working with streams of data.

	(x) `Crypto Module`:
	
		(a) `crypto`: Offers cryptographic functionality, including hashing, encryption, and decryption.

		
	    () `crypto.constants`:
	    () `crypto.fips`:
	    () `crypto.checkPrime(candidate[, options], callback)`:
	    () `crypto.checkPrimeSync(candidate[, options])`:
	    () `crypto.createCipher(algorithm, password[, options])`:
	    () `crypto.createCipheriv(algorithm, key, iv[, options])`:
	    () `crypto.createDecipher(algorithm, password[, options])`:
	    () `crypto.createDecipheriv(algorithm, key, iv[, options])`:
	    () `crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])`:
	    () `crypto.createDiffieHellman(primeLength[, generator])`:
	    () `crypto.createDiffieHellmanGroup(name)`:
	    () `crypto.createECDH(curveName)`:
	    () `crypto.createHash(algorithm[, options])`:
	    () `crypto.createHmac(algorithm, key[, options])`:
	    () `crypto.createPrivateKey(key)`:
	    () `crypto.createPublicKey(key)`:
	    () `crypto.createSecretKey(key[, encoding])`:
	    () `crypto.createSign(algorithm[, options])`:
	    () `crypto.createVerify(algorithm[, options])`:
	    () `crypto.diffieHellman(options)`:
	    () `crypto.generateKey(type, options, callback)`:
	    () `crypto.generateKeyPair(type, options, callback)`:
	    () `crypto.generateKeyPairSync(type, options)`:
	    () `crypto.generateKeySync(type, options)`:
	    () `crypto.generatePrime(size[, options[, callback]])`:
	    () `crypto.generatePrimeSync(size[, options])`:
	    () `crypto.getCipherInfo(nameOrNid[, options])`:
	    () `crypto.getCiphers()`:
	    () `crypto.getCurves()`:
	    () `crypto.getDiffieHellman(groupName)`:
	    () `crypto.getFips()`:
	    () `crypto.getHashes()`:
	    () `crypto.getRandomValues(typedArray)`:
	    () `crypto.hkdf(digest, ikm, salt, info, keylen, callback)`:
	    () `crypto.hkdfSync(digest, ikm, salt, info, keylen)`:
	    () `crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)`:
	    () `crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)`:
	    () `crypto.privateDecrypt(privateKey, buffer)`:
	    () `crypto.privateEncrypt(privateKey, buffer)`:
	    () `crypto.publicDecrypt(key, buffer)`:
	    () `crypto.publicEncrypt(key, buffer)`:
	    () `crypto.randomBytes(size[, callback])`:
	    () `crypto.randomFillSync(buffer[, offset][, size])`:
	    () `crypto.randomFill(buffer[, offset][, size], callback)`:
	    () `crypto.randomInt([min, ]max[, callback])`:
	    () `crypto.randomUUID([options])`:
	    () `crypto.scrypt(password, salt, keylen[, options], callback)`:
	    () `crypto.scryptSync(password, salt, keylen[, options])`:
	    () `crypto.secureHeapUsed()`:
	    () `crypto.setEngine(engine[, flags])`:
	    () `crypto.setFips(bool)`:
	    () `crypto.sign(algorithm, data, key[, callback])`:
	    () `crypto.subtle`:
	    () `crypto.timingSafeEqual(a, b)`:
	    () `crypto.verify(algorithm, data, key, signature[, callback])`:
	    () `crypto.webcrypto`:
		 

	(xi) `Buffer Module`:
	
		(a) `buffer`: Provides a way to interact with binary data directly.

	(xii) `Process Module`:
	
		(a) `process`: Gives information about the current Node.js process and allows interaction with it.

	(xiii) `DNS Module`:
	
		(a) `dns`: Performs DNS-related operations, such as hostname resolution.

	(xiv) `Console Module`:
	
		(a) `console`: Provides a simple debugging console.

	(xv) `Timers Module`:
	
		(a) `setTimeout`, setInterval, and clearTimeout, clearInterval: Enable scheduling functions to be called after a specified time.

	(xvi) `Readline Module`:
	
		(a) `readline`: Provides an interface for reading lines of text from a readable stream.

	(xvii) `Child Process Module`:
	
		(a) `child_process`: Allows you to spawn child processes and interact with them.

	(xviii) `Zlib Module`:
	
		(a) `zlib`: Provides compression and decompression functionalities using the zlib library.

	(xix) `Assert Module`:
	
		(a) `assert`: Provides a simple set of assertion tests.

	(xx) `HTTP2 Module`:
	
		(a) `http2`: Implements the HTTP/2 protocol.

Section: 3rd Paty JavaScript

38. 3rd Party Modules

39. FrontEnd Frameworks

40. Backend Frameworks

	(i) Express.js

		(a) Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It is one of the most popular frameworks for building server-side applications and APIs with Node.js. Here's an overview of key concepts and features in Express:

		(b) Routing: Express allows you to define routes that handle HTTP requests to specific endpoints.

			const express = require('express');
			const app = express();

			app.get('/', (req, res) => {
			  	res.send('Hello, World!');
			});

			(c) the `express()` is the app itself so it has to be declared
		
		(d) Request Types
			
			(a) GET Request:
				
				(I)`app.get(<route>, <callback>)` whenever traffic goes the specified route it run the callback function

		(e) Callback

			(I) The callback takes 2 arguments <req> and <res>

			(II) <req> Object

				(a) <req> represents the incoming data from the client (user)

				(b) req.params: An object containing properties mapped to the named route parameters. For example, if you have a route like /users/:id, req.params will contain { id: 'someValue' }.

				(c) req.query: An object containing the parsed query parameters from the URL. For example, for a URL like /search?q=query&userid=123, req.query will be { q: 'query', userid: '123' }

					(Note: '?' seperates the page and queries and queries are key value pairs seperated by '=', different queries are seperated by '&')


					  Page  separator  key-value   query seperator  key-value
						↓     	↓   	↓    ↓		      ↓			 ↓	  ↓
					/search		?   	q = query   	  &		 userid = 123

				(d) req.body: An object containing data submitted in the request body. This property is requires method to be 'POST' a middleware like `express.json()` for JSON data or `express.urlencoded()` for encoded Data for parsing it into JavaScript Object.

					app.use(express.json()) // for pasing JSON Data from the Body
					app.use(express.urlencoded()) // for pasing Encoded Data from the Body

					app.post('/Blog', (req, res)=>{
						const BlogName = req.body.blogname // Get Data from The Body of The Request
					})

				(e) req.method: A string representing the HTTP method of the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').
				(f) req.url: A string representing the URL path of the request, including the query parameters.
				(g) req.headers: An object containing the HTTP headers of the request.
				(h) req.cookies: An object representing the cookies sent with the request.
				(i) req.protocol: A string representing the protocol used by the request ('http' or 'https').
				(j) req.is(type): A method to check if the request's Content-Type header matches the provided MIME type. Example: `req.is('json')`.
				(k) req.originalUrl:
    			(l) A string representing the original URL of the request, including the original request URL before any rewriting.
				(m) req.xhr: A boolean indicating whether the request was made with `XMLHttpRequest`.
				(n) req.accepts(types): A method to check if the given content types are acceptable based on the request's Accept header.
				(o) req.param(name): A method to access route parameters, query parameters, and the request body. It is deprecated in recent versions of Express, and it's recommended to use `req.params`, `req.query`, and `req.body` directly.

			(III) <res> Object

				(a) <res> represents the Outgoing data from the server

				(b) `res.send([body])`: Sends the HTTP response with the specified data. The body parameter can be a string, a buffer, an object, or an array.
    			(c) `res.json([body])`: Sends a JSON response. The body parameter can be any JSON-serializable data.
    			(d) `res.status(code)`: Sets the HTTP status code for the response. Example: res.status(404).send('Not Found').
    			(e) `res.sendFile(path[, options][, callback])`: Sends a file as an HTTP response. path is the path to the file, and optional options can be used to configure behavior.
    			(f) `res.render(view[, locals][, callback])`: Renders a view template using the configured template engine. view is the name of the view file, and locals is an object containing data to be passed to the view.
    			(g) `res.redirect([status,] path)`: Redirects the client to the specified URL. If status is provided, it sets the HTTP status code for the redirect.
    			(h) `res.set(field, [value])`: Sets the value of an HTTP response header. Example: res.set('Content-Type', 'text/plain').
    			(i) `res.get(field)`: Gets the value of an HTTP request header.
    			(j) `res.cookie(name, value [, options])`: Sets a cookie in the client's browser. name and value are the cookie name and value, and options can include additional parameters like maxAge, expires, and httpOnly.
    			(k) `res.clearCookie(name [, options])`: Clears a cookie previously set with res.cookie(). The options parameter can be used to provide additional settings.
    			(l) `res.locals`: An object that contains response-local variables. These variables are available to views rendered during the current request-response cycle.
    			(m) `res.attachment([filename])`: Sets the Content-Disposition header to provide a hint to the browser to prompt the user to save the file. Optionally, you can specify the filename.
    			(n) `res.type(type)`: Sets the Content-Type header for the response.
    			(o) `res.end([data])`: Ends the response process. If provided, data will be sent as the response body.
    			(p) `res.jsonp([body])`: Sends a JSON response with JSONP support.

		(g) Middlewares

			(I) Middlewares are functions that have access to the <req>, <res>, and the <next> middleware function in the application's request-response cycle. Middleware can be used for tasks like authentication, logging, parsing request bodies, etc.

			Example:

				(A) You can add function in the middle of the route to execute it before the main Function

					const KEY = "some-token"

					function logData(req, res, next){
						console.log(req.headers.Authentication == KEY)
					}

					app.get('/', logData , (req, res) => { // Important: Don't call the middleware functions express will take care of that!
					  	res.send('Hello, World!');
					});

				(B) `next()` function simply makes the middleware exit itself and let the next middleware or the Main Callback run itself.
				(C) express provides `use(<function>)` function to use a middleware for all of the routes that have not been declared yet and their order is important cause they run one by one.

					app.use(express.json()); // Middleware to parse JSON in request body

					app.use((req, res, next) => {
					  	console.log('Request received at:', new Date());
					  	next();
					});

			(II) Error Handling:

				(I) Express provides a way to handle errors using middleware functions with four parameters (err, req, res, next). Example:

				app.use((err, req, res, next) => {
				  	console.error(err.stack);
				  	res.status(500).send('Something went wrong!');
				});

			(III) Static Files:

    			(A) Express makes it easy to serve static files (e.g., HTML, CSS, images) using the express.static middleware.

				app.use(express.static('public'));

		(h) Template Engines:

    		(I) Express can be used with various template engines (like EJS, Pug, Handlebars) to generate dynamic HTML.
    		Example with EJS:

				app.set('view engine', 'ejs');
				app.get('/profile', (req, res) => {
				  	res.render('profile', { username: 'JohnDoe' });
				});

		(i) Routing Parameters:
		
			(I) You can define routes with parameters, allowing dynamic URL segments.
    		Example:

			app.get('/users/:id', (req, res) => {
			  	res.send(`User ID: ${req.params.id}`);
			});

